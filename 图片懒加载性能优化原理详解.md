# 图片懒加载性能优化原理详解

本文档详细分析 `ImageLoadOld` 和 `ImageLoadNew` 两个组件实现图片懒加载性能优化的核心原理。

ImageLoadOld（传统方式）
**关键参数说明**：

- `scrollTop`：元素顶部被滚动隐藏的距离
- `clientHeight`：元素可见区域的高度（不包括滚动条）
- `scrollHeight`：元素内容的总高度（包括不可见部分）
- `threshold`：阈值，提前 100px 触发加载

**判断逻辑**：

```
scrollTop + clientHeight >= scrollHeight - threshold
```

ImageLoadNew（IntersectionObserver）

```
页面初始化
    ↓
onMounted: loadImages() 加载第一页（3 张图片）
    ↓
nextTick: setupObserver() 设置观察器
    ↓
观察最后一个图片元素
    ↓
用户滚动页面
    ↓
最后一个图片元素进入视口（提前 200px）
    ↓
触发 handleIntersection 回调
    ↓
检查条件：isIntersecting && !loading
    ↓
loadImages() 加载下一页
    ↓
停止观察当前元素
    ↓
nextTick: setupObserver() 重新设置观察器（观察新的最后一个元素）
    ↓
循环继续...
```

---

## 两种实现方式对比

### 1. 技术实现对比

| 特性           | ImageLoadOld（传统方式） | ImageLoadNew（IntersectionObserver） |
| -------------- | ------------------------ | ------------------------------------ |
| **检测方式**   | 滚动事件监听             | IntersectionObserver API             |
| **性能**       | 需要频繁计算             | 浏览器原生优化，性能更好             |
| **代码复杂度** | 中等                     | 较高（需要管理观察器）               |
| **兼容性**     | 所有浏览器               | 现代浏览器（IE 不支持）              |
| **提前加载**   | 通过 threshold 实现      | 通过 rootMargin 实现                 |
| **防抖处理**   | ✅ 需要手动实现          | ❌ 不需要（浏览器优化）              |
| **元素引用**   | ❌ 不需要                | ✅ 需要收集元素引用                  |

## 目录

1. [概述](#概述)
2. [ImageLoadOld 组件分析（传统实现方式）](#imageloadold-组件分析传统实现方式)
3. [ImageLoadNew 组件分析（IntersectionObserver 实现方式）](#imageloadnew-组件分析intersectionobserver-实现方式)
4. [两种实现方式对比](#两种实现方式对比)
5. [IntersectionObserver API 深度解析](#intersectionobserver-api-深度解析)
6. [性能优化效果评估](#性能优化效果评估)
7. [最佳实践建议](#最佳实践建议)

---

## 概述

图片懒加载（Lazy Loading）是一种前端性能优化技术，通过延迟加载图片资源来提升页面性能。当页面包含大量图片时，如果一次性加载所有图片，会导致：

- **首屏加载慢**：需要下载大量图片资源
- **带宽浪费**：用户可能不会滚动到底部，但图片已经加载
- **内存占用高**：所有图片都保存在内存中
- **用户体验差**：页面卡顿，交互不流畅

`ImageLoadOld` 和 `ImageLoadNew` 两个组件通过**分页加载**和**懒加载**技术，实现了图片的按需加载，大幅提升了页面性能。

---

## ImageLoadOld 组件分析（传统实现方式）

### 1. 组件位置

**文件路径**：`src/components/custom/image-load-old.vue`

### 2. 核心实现

#### 2.1 数据结构

```typescript
// 生成静态图片路径列表
const totalImages = 9;
const allImages = Array.from({ length: totalImages }, (_, i) => {
  const num = (i + 1).toString().padStart(3, "0");
  return new URL(`../../assets/imgs/${num}.jpg`, import.meta.url).href;
});

// 响应式数据
const loadedImages = ref<string[]>([]); // 已加载的图片列表
const currentPage = ref(1); // 当前页码
const pageSize = 3; // 每页加载数量
const loading = ref(false); // 加载状态
const hasMore = ref(true); // 是否还有更多数据
```

#### 2.2 分页加载逻辑

```typescript
const loadImages = async () => {
  if (loading.value || !hasMore.value) return;

  loading.value = true;
  const start = (currentPage.value - 1) * pageSize;
  const end = start + pageSize;

  // 追加新图片到已加载列表
  loadedImages.value.push(...allImages.slice(start, end));

  hasMore.value = end < allImages.length;
  currentPage.value += 1;
  loading.value = false;
};
```

**关键点**：

- ✅ **分页加载**：每次只加载 3 张图片，而不是一次性加载所有图片
- ✅ **数据追加**：使用 `push(...slice())` 追加数据，保持已有数据
- ✅ **状态管理**：使用 `loading` 防止重复加载，`hasMore` 判断是否还有数据

#### 2.3 滚动到底部判断

```typescript
const isNearBottom = (el: HTMLElement, threshold = 100) => {
  return el.scrollTop + el.clientHeight >= el.scrollHeight - threshold;
};
```

**关键参数说明**：

- `scrollTop`：元素顶部被滚动隐藏的距离
- `clientHeight`：元素可见区域的高度（不包括滚动条）
- `scrollHeight`：元素内容的总高度（包括不可见部分）
- `threshold`：阈值，提前 100px 触发加载

**判断逻辑**：

```
scrollTop + clientHeight >= scrollHeight - threshold
```

当这个条件成立时，说明已经接近底部（距离底部 100px 以内），触发加载更多图片。

#### 2.4 防抖优化

```typescript
const debounce = <T extends (...args: any[]) => void>(fn: T, delay: number) => {
  let timer: ReturnType<typeof setTimeout>;
  return (...args: Parameters<T>) => {
    clearTimeout(timer);
    timer = setTimeout(() => fn(...args), delay);
  };
};

const handleScroll = debounce(() => {
  if (!scrollContainer.value) return;
  if (isNearBottom(scrollContainer.value)) {
    loadImages();
  }
}, 300);
```

**防抖原理**：

- 滚动事件触发频率很高（可能每秒数十次）
- 防抖函数在 300ms 内只执行最后一次调用
- 减少函数执行次数，降低 CPU 占用

**性能提升**：

- 滚动时：每秒可能触发 30-60 次
- 防抖后：每秒最多执行 3-4 次
- **减少 90% 以上的函数调用**

#### 2.5 模板实现

```vue
<template>
  <div ref="scrollContainer" class="scroll-container" @scroll="handleScroll">
    <div v-for="(img, index) in loadedImages" :key="index" class="image-item">
      <img :src="img" alt="图片" />
    </div>
    <div v-if="loading" class="loading">加载中...</div>
    <div v-if="!hasMore" class="no-more">没有更多了~</div>
  </div>
</template>
```

**关键点**：

- 使用 `@scroll` 监听滚动事件
- 只渲染已加载的图片（`loadedImages`）
- 显示加载状态和结束提示

#### 2.6 工作流程

```
页面初始化
    ↓
onMounted: loadImages() 加载第一页（3 张图片）
    ↓
用户滚动页面
    ↓
触发 scroll 事件
    ↓
防抖处理（300ms）
    ↓
判断是否接近底部
    ↓
如果接近底部 && 有更多数据 && 未在加载
    ↓
loadImages() 加载下一页
    ↓
追加图片到 loadedImages
    ↓
更新 DOM，显示新图片
```

---

## ImageLoadNew 组件分析（IntersectionObserver 实现方式）

### 1. 组件位置

**文件路径**：`src/components/custom/image-load-new.vue`

### 2. 核心实现

#### 2.1 IntersectionObserver 配置

```typescript
const CONFIG = {
  totalImages: 9,
  pageSize: 3,
  pathTemplate: (num: string) =>
    new URL(`../../assets/imgs/${num}.jpg`, import.meta.url).href,
  observerOptions: {
    root: null, // 视口作为根元素
    rootMargin: "0px 0px 200px 0px", // 底部提前 200px 触发
    threshold: 0.1, // 10% 可见时触发
  },
} as const;
```

**关键配置说明**：

- `root: null`：使用视口（viewport）作为观察区域
- `rootMargin: '0px 0px 200px 0px'`：在底部提前 200px 触发，提前加载图片
- `threshold: 0.1`：当目标元素 10% 可见时触发回调

#### 2.2 IntersectionObserver 初始化

```typescript
let observer: IntersectionObserver | null = null;

const setupObserver = () => {
  observer?.disconnect(); // 断开之前的观察

  nextTick(() => {
    // 确保 DOM 更新完成
    observer = new IntersectionObserver(
      handleIntersection,
      CONFIG.observerOptions,
    );

    // 只观察最后一个有效元素
    const validElements = itemRefs.value.filter(
      (el) => el.isConnected && el.offsetParent !== null,
    );

    const lastItem = validElements[validElements.length - 1];

    if (lastItem) {
      observer.observe(lastItem); // 观察最后一个图片元素
    }
  });
};
```

**关键点**：

- ✅ **只观察最后一个元素**：当最后一个图片进入视口时，加载更多
- ✅ **元素有效性检查**：确保元素已连接到 DOM 且可见
- ✅ **nextTick 确保 DOM 更新**：在 DOM 更新完成后再设置观察器

#### 2.3 交叉观察回调处理

```typescript
const handleIntersection: ObserverCallback = (entries) => {
  entries.forEach((entry) => {
    if (entry.isIntersecting && !loading.value) {
      loadImages(); // 加载更多图片
      observer?.unobserve(entry.target); // 停止观察当前元素
    }
  });
};
```

**工作流程**：

1. 当被观察的元素进入视口时，触发回调
2. 检查 `entry.isIntersecting` 是否为 `true`
3. 检查是否正在加载（`!loading.value`）
4. 如果条件满足，加载更多图片
5. 停止观察当前元素（因为已经加载了新元素）

#### 2.4 元素引用收集

```typescript
const itemRefs = ref<HTMLElement[]>([]);

const setItemRef = (el: Element | ComponentPublicInstance | null) => {
  if (!el) return;

  // 处理组件实例的情况
  const domEl = (el as ComponentPublicInstance).$el ?? el;

  if (domEl instanceof HTMLElement) {
    // 去重处理
    if (!itemRefs.value.includes(domEl)) {
      itemRefs.value.push(domEl);
    }
  }
};
```

**关键点**：

- 收集所有图片元素的引用
- 处理 Vue 组件实例的情况（`$el`）
- 去重处理，避免重复添加

#### 2.5 图片加载状态管理

```typescript
const loadedStatus = ref<ImageStatus>([]);

const handleImageLoad = (index: number) => {
  loadedStatus.value[index] = true;
};

const loadImages = async () => {
  // ... 加载逻辑

  // 初始化加载状态
  loadedStatus.value = [
    ...loadedStatus.value,
    ...Array.from<boolean>({
      length: Math.min(CONFIG.pageSize, allImages.length - start),
    }),
  ];

  // 加载完成后重新设置观察器
  nextTick(() => setupObserver());
};
```

**状态管理**：

- 跟踪每张图片的加载状态
- 图片加载完成后更新状态
- 用于显示加载动画和淡入效果

#### 2.6 模板实现

```vue
<template>
  <div class="scroll-container">
    <div
      v-for="(img, index) in loadedImages"
      :key="index"
      :ref="(el) => setItemRef(el)"
      class="image-item"
    >
      <img
        :src="img"
        alt="Gallery Image"
        :class="{ loaded: loadedStatus[index] }"
        @load="handleImageLoad(index)"
      />
      <div v-if="!loadedStatus[index]" class="loading-indicator">
        <div class="loader"></div>
      </div>
    </div>
    <div v-if="loading" class="loading-more">加载中...</div>
    <div v-if="!hasMore" class="no-more">已加载全部内容</div>
  </div>
</template>
```

**关键特性**：

- ✅ **元素引用收集**：使用 `:ref="el => setItemRef(el)"` 收集元素引用
- ✅ **加载状态显示**：图片未加载时显示加载动画
- ✅ **淡入动画**：图片加载完成后通过 CSS 类 `loaded` 实现淡入效果

#### 2.7 CSS 动画效果

```css
img {
  opacity: 0;
  transition:
    opacity 0.3s ease,
    transform 0.3s ease;
}

img.loaded {
  opacity: 1;
  transform: scale(1.02);
}
```

**用户体验优化**：

- 图片初始透明度为 0
- 加载完成后淡入显示（`opacity: 1`）
- 轻微放大效果（`scale(1.02)`）提升视觉体验

#### 2.8 工作流程

```
页面初始化
    ↓
onMounted: loadImages() 加载第一页（3 张图片）
    ↓
nextTick: setupObserver() 设置观察器
    ↓
观察最后一个图片元素
    ↓
用户滚动页面
    ↓
最后一个图片元素进入视口（提前 200px）
    ↓
触发 handleIntersection 回调
    ↓
检查条件：isIntersecting && !loading
    ↓
loadImages() 加载下一页
    ↓
停止观察当前元素
    ↓
nextTick: setupObserver() 重新设置观察器（观察新的最后一个元素）
    ↓
循环继续...
```

---

## 两种实现方式对比

### 1. 技术实现对比

| 特性           | ImageLoadOld（传统方式） | ImageLoadNew（IntersectionObserver） |
| -------------- | ------------------------ | ------------------------------------ |
| **检测方式**   | 滚动事件监听             | IntersectionObserver API             |
| **性能**       | 需要频繁计算             | 浏览器原生优化，性能更好             |
| **代码复杂度** | 中等                     | 较高（需要管理观察器）               |
| **兼容性**     | 所有浏览器               | 现代浏览器（IE 不支持）              |
| **提前加载**   | 通过 threshold 实现      | 通过 rootMargin 实现                 |
| **防抖处理**   | ✅ 需要手动实现          | ❌ 不需要（浏览器优化）              |
| **元素引用**   | ❌ 不需要                | ✅ 需要收集元素引用                  |

### 2. 性能对比

#### 2.1 CPU 占用

**传统方式（ImageLoadOld）**：

- 滚动事件每秒触发 30-60 次
- 即使使用防抖，仍需要执行判断逻辑
- CPU 占用：中等

**IntersectionObserver 方式（ImageLoadNew）**：

- 浏览器原生 API，内部优化
- 只在元素进入/离开视口时触发
- CPU 占用：低

#### 2.2 内存占用

两种方式内存占用基本相同：

- 只加载可见区域的图片
- 已加载的图片保存在内存中
- 通过分页控制内存占用

#### 2.3 用户体验

**传统方式**：

- ✅ 兼容性好
- ❌ 需要手动实现防抖
- ❌ 滚动时可能有轻微卡顿

**IntersectionObserver 方式**：

- ✅ 性能更好，滚动更流畅
- ✅ 自动优化，无需防抖
- ✅ 支持更精确的触发控制
- ✅ 更好的加载动画效果

### 3. 适用场景

#### 3.1 使用传统方式的场景

- ✅ 需要支持旧版浏览器（IE）
- ✅ 项目代码简单，不需要复杂功能
- ✅ 图片数量较少（< 50 张）

#### 3.2 使用 IntersectionObserver 的场景

- ✅ 现代浏览器环境
- ✅ 大量图片需要懒加载（> 50 张）
- ✅ 需要更好的性能和用户体验
- ✅ 需要精确的触发控制

---

## IntersectionObserver API 深度解析

### 1. API 概述

`IntersectionObserver` 是浏览器提供的原生 API，用于异步观察目标元素与其祖先元素或视口的交叉状态。

### 2. 构造函数

```typescript
const observer = new IntersectionObserver(callback, options);
```

#### 2.1 回调函数（callback）

```typescript
const callback = (
  entries: IntersectionObserverEntry[],
  observer: IntersectionObserver,
) => {
  entries.forEach((entry) => {
    // entry.isIntersecting: 元素是否在视口中
    // entry.intersectionRatio: 可见比例（0-1）
    // entry.boundingClientRect: 元素的位置信息
    // entry.rootBounds: 根元素的位置信息
  });
};
```

#### 2.2 配置选项（options）

```typescript
const options = {
  root: null, // 根元素，null 表示视口
  rootMargin: "0px 0px 200px 0px", // 根元素的边距
  threshold: 0.1, // 触发阈值（0-1）
};
```

**配置说明**：

- **root**：

  - `null`：使用视口作为根元素
  - `HTMLElement`：使用指定元素作为根元素

- **rootMargin**：

  - 类似 CSS 的 `margin` 属性
  - 可以提前或延后触发区域
  - 例如：`'0px 0px 200px 0px'` 表示底部提前 200px

- **threshold**：
  - `0`：元素刚进入视口时触发
  - `1`：元素完全进入视口时触发
  - `[0, 0.5, 1]`：在多个阈值点触发

### 3. 核心方法

#### 3.1 observe()

```typescript
observer.observe(element); // 开始观察元素
```

#### 3.2 unobserve()

```typescript
observer.unobserve(element); // 停止观察元素
```

#### 3.3 disconnect()

```typescript
observer.disconnect(); // 断开所有观察
```

### 4. IntersectionObserverEntry 对象

```typescript
interface IntersectionObserverEntry {
  // 目标元素
  target: Element;

  // 是否在视口中
  isIntersecting: boolean;

  // 可见比例（0-1）
  intersectionRatio: number;

  // 目标元素的位置信息
  boundingClientRect: DOMRectReadOnly;

  // 根元素的位置信息
  rootBounds: DOMRectReadOnly | null;

  // 交叉区域的位置信息
  intersectionRect: DOMRectReadOnly;

  // 时间戳
  time: number;
}
```

### 5. 工作原理

```
┌─────────────────────────────────┐
│  视口 (Viewport)                 │
│  ┌───────────────────────────┐  │
│  │                           │  │
│  │  rootMargin: 200px       │  │ ← 提前触发区域
│  │  ┌─────────────────────┐  │  │
│  │  │                     │  │  │
│  │  │  观察区域            │  │  │
│  │  │                     │  │  │
│  │  └─────────────────────┘  │  │
│  │                           │  │
│  └───────────────────────────┘  │
│                                  │
│  ↓ 目标元素进入观察区域          │
│                                  │
│  [图片元素]                      │ ← 触发回调
└─────────────────────────────────┘
```

### 6. 优势

1. **性能优化**：

   - 浏览器原生实现，性能更好
   - 不需要频繁计算滚动位置
   - 自动优化，减少 CPU 占用

2. **精确控制**：

   - 可以精确控制触发时机
   - 支持多个阈值
   - 支持提前触发（rootMargin）

3. **代码简洁**：
   - 不需要手动计算滚动位置
   - 不需要防抖处理
   - API 设计更直观

---

## 性能优化效果评估

### 1. 性能指标对比

假设有 **100 张图片**，每张图片 **500KB**：

| 指标                   | 一次性加载 | 传统懒加载 | IntersectionObserver 懒加载 |
| ---------------------- | ---------- | ---------- | --------------------------- |
| **首屏加载时间**       | 5-10 秒    | 1-2 秒     | 1-2 秒                      |
| **初始网络请求**       | 100 个     | 3-6 个     | 3-6 个                      |
| **初始带宽占用**       | ~50MB      | ~1.5-3MB   | ~1.5-3MB                    |
| **CPU 占用（滚动时）** | 高         | 中等       | 低                          |
| **内存占用**           | ~50MB      | ~1.5-3MB   | ~1.5-3MB                    |
| **用户体验**           | 差         | 良好       | 优秀                        |

### 2. 实际测试场景

#### 2.1 小量图片（< 20 张）

- **一次性加载**：性能可接受
- **懒加载**：性能提升不明显，但无负面影响
- **建议**：可以使用懒加载，但不是必需的

#### 2.2 中量图片（20-50 张）

- **一次性加载**：开始出现性能问题
- **懒加载**：性能提升明显
- **建议**：推荐使用懒加载

#### 2.3 大量图片（> 50 张）

- **一次性加载**：严重性能问题，几乎不可用
- **懒加载**：性能优秀，用户体验好
- **建议**：必须使用懒加载

### 3. 带宽节省分析

```
场景：100 张图片，每张 500KB

一次性加载：
- 总带宽：100 × 500KB = 50MB
- 用户可能只看前 10 张
- 浪费带宽：45MB（90%）

懒加载：
- 初始加载：3-6 张 = 1.5-3MB
- 按需加载：用户滚动到哪里，加载到哪里
- 节省带宽：47-48.5MB（94-97%）
```

**带宽节省**：约 **90-95%**

---

## 最佳实践建议

### 1. 选择合适的实现方式

#### 1.1 使用传统方式的场景

- ✅ 需要支持旧版浏览器（IE 11 及以下）
- ✅ 图片数量较少（< 20 张）
- ✅ 项目代码简单，不需要复杂功能

#### 1.2 使用 IntersectionObserver 的场景

- ✅ 现代浏览器环境（Chrome、Firefox、Safari、Edge）
- ✅ 大量图片需要懒加载（> 20 张）
- ✅ 需要更好的性能和用户体验
- ✅ 需要精确的触发控制

### 2. 配置建议

#### 2.1 分页大小

```typescript
// ✅ 推荐：每次加载 3-6 张
const pageSize = 3;

// ❌ 不推荐：单次加载过多（> 10 张）
const pageSize = 20;
```

#### 2.2 提前触发距离

```typescript
// ✅ 推荐：提前 100-300px
rootMargin: "0px 0px 200px 0px";

// ❌ 不推荐：提前过多（> 500px）或过少（< 50px）
rootMargin: "0px 0px 1000px 0px";
```

#### 2.3 防抖时间（传统方式）

```typescript
// ✅ 推荐：200-500ms
const handleScroll = debounce(() => {
  // ...
}, 300);

// ❌ 不推荐：时间过短（< 100ms）或过长（> 1000ms）
const handleScroll = debounce(() => {
  // ...
}, 50);
```

### 3. 常见问题与解决方案

#### 3.1 图片加载失败

**问题**：网络错误导致图片加载失败

**解决方案**：

```typescript
<img
  :src="img"
  @error="handleImageError"
  alt="图片"
/>

const handleImageError = (event: Event) => {
  const img = event.target as HTMLImageElement;
  img.src = '/default-image.jpg'; // 使用默认图片
};
```

#### 3.2 重复加载

**问题**：快速滚动导致重复触发加载

**解决方案**：

```typescript
const loadImages = async () => {
  if (loading.value || !hasMore.value) return; // 防止重复加载
  // ...
};
```

#### 3.3 内存泄漏

**问题**：观察器未清理导致内存泄漏

**解决方案**：

```typescript
onBeforeUnmount(() => {
  observer?.disconnect(); // 清理观察器
  observer = null;
});
```

#### 3.4 IntersectionObserver 兼容性

**问题**：旧版浏览器不支持

**解决方案**：

```typescript
// 使用 polyfill
import "intersection-observer";

// 或降级到传统方式
if ("IntersectionObserver" in window) {
  // 使用 IntersectionObserver
} else {
  // 使用传统滚动事件
}
```

### 4. 性能监控

```typescript
// 监控图片加载性能
const startTime = performance.now();
img.addEventListener("load", () => {
  const endTime = performance.now();
  console.log(`图片加载耗时: ${endTime - startTime}ms`);
});

// 监控内存占用
if (performance.memory) {
  console.log(
    `内存使用: ${(performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(2)}MB`,
  );
}
```

### 5. 图片优化建议

#### 5.1 使用响应式图片

```html
<img
  srcset="image-small.jpg 480w, image-medium.jpg 768w, image-large.jpg 1200w"
  sizes="(max-width: 480px) 100vw, (max-width: 768px) 50vw, 33vw"
  src="image-medium.jpg"
  alt="响应式图片"
/>
```

#### 5.2 使用 WebP 格式

```typescript
// 检测浏览器支持
const supportsWebP = () => {
  const canvas = document.createElement("canvas");
  return canvas.toDataURL("image/webp").indexOf("data:image/webp") === 0;
};

// 根据支持情况选择图片格式
const imageUrl = supportsWebP() ? "image.webp" : "image.jpg";
```

#### 5.3 图片压缩

- 使用工具压缩图片（如 TinyPNG、ImageOptim）
- 根据显示尺寸调整图片大小
- 使用适当的图片格式（WebP、AVIF）

---

## 总结

### 核心优化技术

1. **分页加载（Pagination）**

   - 每次只加载少量图片（3-6 张）
   - 控制初始加载量，提升首屏速度
   - 按需加载，节省带宽

2. **懒加载（Lazy Loading）**

   - 只加载可见区域的图片
   - 用户滚动时按需加载
   - 大幅减少初始加载时间

3. **IntersectionObserver API**

   - 浏览器原生 API，性能更好
   - 精确控制触发时机
   - 自动优化，无需防抖

4. **防抖优化（传统方式）**
   - 减少滚动事件处理频率
   - 降低 CPU 占用
   - 提升滚动流畅度

### 性能提升效果

- **首屏加载时间**：提升 **5-10 倍**
- **初始带宽占用**：减少 **90-95%**
- **内存占用**：减少 **90-95%**
- **用户体验**：大幅提升

### 适用场景

- ✅ 图片数量 > 20 张
- ✅ 需要快速的首屏加载
- ✅ 需要节省带宽
- ✅ 需要良好的用户体验

通过合理使用图片懒加载技术，可以轻松处理数百甚至数千张图片，同时保持良好的性能和用户体验。
