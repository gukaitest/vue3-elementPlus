# 前端错误监控原理详解与面试问答

本文档详细分析 `ErrorMonitor` 组件实现的前端错误监控系统，包括技术详解、技术选型原因以及面试常见问题与解答。

## 目录

1. [概述](#概述)
2. [错误类型详解](#错误类型详解)
3. [错误捕获机制](#错误捕获机制)
4. [技术选型原因](#技术选型原因)
5. [错误处理流程](#错误处理流程)
6. [批量上报机制](#批量上报机制)
7. [错误去重机制](#错误去重机制)
8. [面试问题与解答](#面试问题与解答)
9. [最佳实践建议](#最佳实践建议)

---

## 概述

前端错误监控是前端工程化的重要组成部分，通过捕获和分析用户真实环境下的错误，帮助开发者：

- **快速定位问题**：及时发现和定位生产环境错误
- **提升用户体验**：减少错误对用户体验的影响
- **优化代码质量**：通过错误分析指导代码优化
- **业务价值**：降低错误率，提升业务指标

本实现监控了 **6 种错误类型**，提供了完整的错误捕获、过滤、去重和批量上报机制。

---

## 错误类型详解

### 1. JavaScript 错误

#### 1.1 定义

**JavaScript 错误**包括同步错误和异步错误，是最常见的错误类型。

#### 1.2 捕获方式

**同步错误**：使用 `window.onerror`

```typescript
window.onerror = (message, filename, lineno, colno, error) => {
  const errorInfo: ErrorInfo = {
    type: ErrorType.JAVASCRIPT,
    message: String(message),
    filename: String(filename),
    lineno: Number(lineno),
    colno: Number(colno),
    stack: error?.stack,
    url: window.location.href,
    userAgent: navigator.userAgent,
    timestamp: Date.now()
  };
  
  errorCollector.collect(errorInfo);
  return false; // 返回 false 让错误继续传播
};
```

**异步错误**：使用 `window.addEventListener('error')`

```typescript
window.addEventListener('error', event => {
  const errorInfo: ErrorInfo = {
    type: ErrorType.JAVASCRIPT,
    message: event.message,
    filename: event.filename,
    lineno: event.lineno,
    colno: event.colno,
    stack: event.error?.stack,
    url: window.location.href,
    userAgent: navigator.userAgent,
    timestamp: Date.now()
  };
  
  errorCollector.collect(errorInfo);
});
```

#### 1.3 错误级别

默认级别：**HIGH**（高级）

### 2. Vue 错误

#### 2.1 定义

**Vue 错误**是在 Vue 组件渲染、生命周期钩子或事件处理函数中发生的错误。

#### 2.2 捕获方式

使用 Vue 的 `errorHandler`：

```typescript
export function setupVueErrorHandler(app: any): void {
  app.config.errorHandler = (error: Error, instance: any, info: string) => {
    const errorInfo: ErrorInfo = {
      type: ErrorType.VUE,
      message: error.message,
      stack: error.stack,
      componentName: instance?.$options?.name || 'Unknown',
      componentStack: info,
      propsData: instance?.$props,
      route: instance?.$route?.path,
      routeParams: instance?.$route?.params,
      routeQuery: instance?.$route?.query,
      url: window.location.href,
      userAgent: navigator.userAgent,
      timestamp: Date.now()
    };
    
    errorCollector.collect(errorInfo);
  };
}
```

#### 2.3 捕获的信息

- **组件名称**：发生错误的组件名称
- **组件堆栈**：Vue 组件调用堆栈
- **Props 数据**：组件的 props 数据
- **路由信息**：当前路由路径、参数、查询参数

#### 2.4 错误级别

默认级别：**HIGH**（高级）

### 3. Promise 错误

#### 3.1 定义

**Promise 错误**是未处理的 Promise 拒绝（unhandled promise rejection）。

#### 3.2 捕获方式

使用 `unhandledrejection` 事件：

```typescript
window.addEventListener('unhandledrejection', event => {
  const error = event.reason;
  let message = 'Unhandled Promise Rejection';
  let stack = '';
  
  if (error instanceof Error) {
    message = error.message;
    stack = error.stack || '';
  } else if (typeof error === 'string') {
    message = error;
  } else if (error && typeof error === 'object') {
    message = JSON.stringify(error);
  }
  
  const errorInfo: ErrorInfo = {
    type: ErrorType.PROMISE,
    message,
    stack,
    url: window.location.href,
    userAgent: navigator.userAgent,
    timestamp: Date.now()
  };
  
  errorCollector.collect(errorInfo);
});
```

#### 3.3 错误级别

默认级别：**MEDIUM**（中级）

### 4. 资源错误

#### 4.1 定义

**资源错误**是图片、脚本、样式表等资源加载失败的错误。

#### 4.2 捕获方式

使用 `error` 事件（捕获阶段）：

```typescript
window.addEventListener(
  'error',
  event => {
    const target = event.target as HTMLElement;
    
    // 检查是否是资源加载错误
    if (target && target.nodeName && 
        target.nodeName !== 'HTML' && 
        target.nodeName !== 'BODY') {
      const resourceType = target.nodeName.toLowerCase();
      const resourceUrl = (target as any).src || (target as any).href || '';
      
      const errorInfo: ErrorInfo = {
        type: ErrorType.RESOURCE,
        message: `Failed to load ${resourceType}: ${resourceUrl}`,
        resourceType,
        resourceUrl,
        url: window.location.href,
        userAgent: navigator.userAgent,
        timestamp: Date.now()
      };
      
      errorCollector.collect(errorInfo);
    }
  },
  true // 使用捕获阶段
);
```

**为什么使用捕获阶段？**

- ✅ **更早捕获**：在捕获阶段捕获，确保不会遗漏
- ✅ **不冒泡**：资源错误不会冒泡到 window，必须在捕获阶段捕获

#### 4.3 错误级别

默认级别：**MEDIUM**（中级）

### 5. Ajax 错误

#### 5.1 定义

**Ajax 错误**是 HTTP 请求失败的错误，包括网络错误、超时、服务器错误等。

#### 5.2 捕获方式

使用 Axios 拦截器：

```typescript
export function setupAxiosErrorHandler(axiosInstance: any): void {
  // 请求拦截器
  axiosInstance.interceptors.request.use(
    (config: any) => {
      config._requestStartTime = Date.now();
      return config;
    },
    (error: any) => {
      // 请求配置错误
      const errorInfo: ErrorInfo = {
        type: ErrorType.AJAX,
        message: `Request Error: ${error.message}`,
        requestUrl: error.config?.url,
        requestMethod: error.config?.method,
        requestData: error.config?.data,
        url: window.location.href,
        userAgent: navigator.userAgent,
        timestamp: Date.now()
      };
      
      errorCollector.collect(errorInfo);
      return Promise.reject(error);
    }
  );
  
  // 响应拦截器
  axiosInstance.interceptors.response.use(
    (response: any) => response,
    (error: any) => {
      const requestDuration = error.config?._requestStartTime 
        ? Date.now() - error.config._requestStartTime 
        : 0;
      
      const errorInfo: ErrorInfo = {
        type: ErrorType.AJAX,
        message: `Response Error: ${error.message}`,
        requestUrl: error.config?.url,
        requestMethod: error.config?.method,
        requestData: error.config?.data,
        responseStatus: error.response?.status,
        responseData: error.response?.data,
        customData: {
          requestDuration,
          timeout: error.code === 'ECONNABORTED'
        },
        url: window.location.href,
        userAgent: navigator.userAgent,
        timestamp: Date.now()
      };
      
      errorCollector.collect(errorInfo);
      return Promise.reject(error);
    }
  );
}
```

#### 5.3 捕获的信息

- **请求 URL**：请求的 URL
- **请求方法**：GET、POST、PUT、DELETE 等
- **请求数据**：请求的 body 数据
- **响应状态**：HTTP 状态码（如 404、500）
- **响应数据**：错误响应数据
- **请求时长**：请求持续时间

#### 5.4 错误级别

默认级别：**MEDIUM**（中级）

### 6. 自定义错误

#### 6.1 定义

**自定义错误**是开发者手动上报的错误，用于业务逻辑错误等场景。

#### 6.2 上报方式

使用 `reportCustomError` 函数：

```typescript
export function reportCustomError(
  message: string, 
  customData?: any, 
  level: ErrorLevel = ErrorLevel.LOW
): void {
  const errorInfo: ErrorInfo = {
    type: ErrorType.CUSTOM,
    message,
    customData,
    level,
    url: window.location.href,
    userAgent: navigator.userAgent,
    timestamp: Date.now()
  };
  
  errorCollector.collect(errorInfo);
}
```

#### 6.3 使用场景

- 业务逻辑错误
- 数据验证失败
- 用户操作异常
- 第三方服务错误

#### 6.4 错误级别

默认级别：**LOW**（低级），可自定义

---

## 错误捕获机制

### 1. 同步错误捕获

#### 1.1 window.onerror

```typescript
window.onerror = (message, filename, lineno, colno, error) => {
  // 捕获同步错误
  // 注意：只能捕获同步错误，不能捕获异步错误
};
```

**特点**：

- ✅ 可以捕获同步错误
- ❌ 不能捕获异步错误
- ❌ 不能捕获 Promise 错误
- ❌ 不能捕获资源错误

#### 1.2 为什么还需要 addEventListener('error')？

`window.onerror` 只能捕获同步错误，异步错误需要使用 `addEventListener('error')`。

### 2. 异步错误捕获

#### 2.1 addEventListener('error')

```typescript
window.addEventListener('error', event => {
  // 捕获异步错误
  // 可以捕获异步错误和资源错误
});
```

**特点**：

- ✅ 可以捕获异步错误
- ✅ 可以捕获资源错误（在捕获阶段）
- ❌ 不能捕获 Promise 错误

### 3. Promise 错误捕获

#### 3.1 unhandledrejection 事件

```typescript
window.addEventListener('unhandledrejection', event => {
  // 捕获未处理的 Promise 拒绝
});
```

**特点**：

- ✅ 可以捕获 Promise 错误
- ✅ 可以捕获 async/await 错误

### 4. 资源错误捕获

#### 4.1 捕获阶段监听

```typescript
window.addEventListener('error', event => {
  const target = event.target;
  if (target && target.nodeName !== 'HTML' && target.nodeName !== 'BODY') {
    // 资源加载错误
  }
}, true); // 使用捕获阶段
```

**为什么使用捕获阶段？**

- 资源错误不会冒泡到 window
- 必须在捕获阶段捕获

### 5. Vue 错误捕获

#### 5.1 errorHandler

```typescript
app.config.errorHandler = (error, instance, info) => {
  // 捕获 Vue 组件错误
};
```

**捕获范围**：

- 组件渲染错误
- 生命周期钩子错误
- 事件处理函数错误
- 自定义指令错误

### 6. 错误捕获优先级

```
同步错误 → window.onerror
异步错误 → addEventListener('error')
Promise 错误 → unhandledrejection
资源错误 → addEventListener('error', true)
Vue 错误 → errorHandler
Ajax 错误 → Axios 拦截器
```

---

## 技术选型原因

### 1. 为什么使用 window.onerror + addEventListener('error')？

#### 1.1 技术对比

| 方式 | 同步错误 | 异步错误 | Promise 错误 | 资源错误 |
|------|---------|---------|-------------|---------|
| **window.onerror** | ✅ | ❌ | ❌ | ❌ |
| **addEventListener('error')** | ✅ | ✅ | ❌ | ✅（捕获阶段）|
| **unhandledrejection** | ❌ | ❌ | ✅ | ❌ |

#### 1.2 选型原因

- ✅ **全面覆盖**：组合使用可以捕获所有类型的错误
- ✅ **兼容性好**：所有现代浏览器都支持
- ✅ **性能友好**：事件监听器性能开销小

### 2. 为什么使用 Axios 拦截器捕获 Ajax 错误？

#### 2.1 技术对比

| 方式 | 优势 | 劣势 |
|------|------|------|
| **Axios 拦截器** | 统一处理、信息完整 | 只适用于 Axios |
| **fetch 包装** | 适用于 fetch | 需要包装所有 fetch |
| **XMLHttpRequest 包装** | 适用于原生 XHR | 需要包装所有 XHR |

#### 2.2 选型原因

- ✅ **统一处理**：所有请求统一处理，代码简洁
- ✅ **信息完整**：可以获取请求和响应的完整信息
- ✅ **易于扩展**：可以添加请求时长、重试等逻辑

### 3. 为什么使用批量上报？

#### 3.1 技术对比

| 方式 | 优势 | 劣势 |
|------|------|------|
| **批量上报** | 减少请求数、提高效率 | 实现复杂 |
| **单个上报** | 简单、实时 | 请求多、效率低 |
| **本地存储** | 离线支持 | 需要额外处理 |

#### 3.2 选型原因

- ✅ **减少请求数**：10 条错误合并为 1 个请求，减少 90% 请求数
- ✅ **提高效率**：减少网络开销，提高上报效率
- ✅ **降低服务器压力**：减少服务器处理请求的压力

### 4. 为什么使用 sendBeacon？

#### 4.1 技术对比

| 方式 | 可靠性 | 阻塞性 | 兼容性 |
|------|--------|--------|--------|
| **sendBeacon** | ✅ 高 | ✅ 不阻塞 | ✅ 现代浏览器 |
| **同步 XMLHttpRequest** | ✅ 高 | ❌ 阻塞 | ✅ 所有浏览器 |
| **fetch** | ❌ 低 | ✅ 不阻塞 | ✅ 现代浏览器 |

#### 4.2 选型原因

- ✅ **可靠性高**：即使页面卸载也能发送数据
- ✅ **不阻塞**：异步发送，不阻塞页面卸载
- ✅ **自动重试**：浏览器自动处理网络问题

---

## 错误处理流程

### 1. 完整流程

```
错误发生
    ↓
错误捕获（window.onerror / addEventListener / errorHandler）
    ↓
构建 ErrorInfo 对象
    ↓
错误过滤（ignoreErrors / ignoreUrls）
    ↓
生成错误ID（用于去重）
    ↓
设置错误级别
    ↓
添加到错误列表
    ↓
采样率检查
    ↓
批量上报队列 / 单个上报
    ↓
服务器存储
```

### 2. 错误过滤流程

```typescript
private shouldIgnoreError(errorInfo: ErrorInfo): boolean {
  const { ignoreErrors = [], ignoreUrls = [] } = this.config;
  
  // 检查错误消息
  if (ignoreErrors.length > 0) {
    const shouldIgnore = ignoreErrors.some(pattern => {
      if (typeof pattern === 'string') {
        return errorInfo.message.includes(pattern);
      }
      return pattern.test(errorInfo.message);
    });
    if (shouldIgnore) return true;
  }
  
  // 检查URL
  if (ignoreUrls.length > 0) {
    const shouldIgnore = ignoreUrls.some(pattern => {
      if (typeof pattern === 'string') {
        return errorInfo.url.includes(pattern);
      }
      return pattern.test(errorInfo.url);
    });
    if (shouldIgnore) return true;
  }
  
  return false;
}
```

### 3. 错误去重流程

```typescript
private generateErrorId(errorInfo: ErrorInfo): string {
  const key = `${errorInfo.type}_${errorInfo.message}_${errorInfo.filename}_${errorInfo.lineno}`;
  
  try {
    return btoa(key)
      .replace(/[^a-zA-Z0-9]/g, '')
      .substr(0, 16);
  } catch (error) {
    const encodedKey = encodeURIComponent(key);
    return btoa(encodedKey)
      .replace(/[^a-zA-Z0-9]/g, '')
      .substr(0, 16);
  }
}
```

**去重原理**：

- 使用错误类型、消息、文件名、行号生成唯一 ID
- 相同错误生成相同 ID，用于去重统计

---

## 批量上报机制

### 1. 批量上报原理

#### 1.1 队列管理

```typescript
interface BatchReportQueue {
  queue: ErrorInfo[];
  timer: number | null;
  config: {
    batchSize: number;        // 批量大小（默认 10）
    batchInterval: number;    // 批量间隔（默认 120 秒）
    batchReportUrl: string;    // 上报 URL
  };
  isEnabled: boolean;
}
```

#### 1.2 添加数据到队列

```typescript
private addToBatchQueue(errorInfo: ErrorInfo): void {
  this.batchReportQueue.queue.push(errorInfo);
  
  // 检查是否达到批量大小
  if (this.batchReportQueue.queue.length >= this.batchReportQueue.config.batchSize) {
    this.flushBatchReport(); // 立即上报
    return;
  }
  
  // 设置定时器，超时后自动上报
  if (this.batchReportQueue.timer === null) {
    this.batchReportQueue.timer = window.setTimeout(() => {
      this.flushBatchReport();
    }, this.batchReportQueue.config.batchInterval);
  }
}
```

#### 1.3 执行批量上报

```typescript
private async flushBatchReport(): Promise<void> {
  const dataToReport = [...this.batchReportQueue.queue];
  
  // 清空队列
  this.batchReportQueue.queue = [];
  
  // 清除定时器
  if (this.batchReportQueue.timer !== null) {
    clearTimeout(this.batchReportQueue.timer);
    this.batchReportQueue.timer = null;
  }
  
  // 上报数据
  await fetch(this.batchReportQueue.config.batchReportUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      batch: dataToReport,
      batchSize: dataToReport.length,
      batchTimestamp: Date.now()
    })
  });
}
```

### 2. 页面卸载处理

#### 2.1 sendBeacon API

```typescript
window.addEventListener('beforeunload', () => {
  if (this.batchReportQueue.queue.length > 0) {
    const data = JSON.stringify({
      batch: this.batchReportQueue.queue,
      batchSize: this.batchReportQueue.queue.length,
      batchTimestamp: Date.now()
    });
    
    // 使用 sendBeacon 确保数据不丢失
    navigator.sendBeacon(this.batchReportQueue.config.batchReportUrl, data);
  }
});
```

#### 2.2 visibilitychange 事件

```typescript
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'hidden' && 
      this.batchReportQueue.queue.length > 0) {
    this.flushBatchReport(); // 页面隐藏时上报
  }
});
```

---

## 错误去重机制

### 1. 错误ID生成

#### 1.1 生成算法

```typescript
private generateErrorId(errorInfo: ErrorInfo): string {
  const key = `${errorInfo.type}_${errorInfo.message}_${errorInfo.filename}_${errorInfo.lineno}`;
  
  try {
    return btoa(key)
      .replace(/[^a-zA-Z0-9]/g, '')
      .substr(0, 16);
  } catch (error) {
    // 处理非 Latin1 字符
    const encodedKey = encodeURIComponent(key);
    return btoa(encodedKey)
      .replace(/[^a-zA-Z0-9]/g, '')
      .substr(0, 16);
  }
}
```

#### 1.2 去重原理

- **相同错误**：类型、消息、文件名、行号相同 → 生成相同 ID
- **不同错误**：任意一项不同 → 生成不同 ID

#### 1.3 去重优势

- ✅ **减少重复**：相同错误只记录一次
- ✅ **统计准确**：可以统计错误出现次数
- ✅ **节省存储**：减少数据库存储空间

### 2. 后端去重

#### 2.1 数据库索引

```javascript
// MongoDB 索引
errorMonitorSchema.index({ errorId: 1 });
```

#### 2.2 去重逻辑

```javascript
// 后端可以根据 errorId 去重
// 相同 errorId 的错误可以合并统计
```

---

## 面试问题与解答

### Q1: 如何捕获 JavaScript 错误？有哪些方式？

**答案**：

**捕获方式**：

1. **window.onerror**：捕获同步错误
2. **addEventListener('error')**：捕获异步错误和资源错误
3. **unhandledrejection**：捕获 Promise 错误
4. **errorHandler**：捕获 Vue 组件错误
5. **Axios 拦截器**：捕获 HTTP 请求错误

**实现代码**：

```typescript
// 1. 同步错误
window.onerror = (message, filename, lineno, colno, error) => {
  console.error('同步错误:', message);
  return false;
};

// 2. 异步错误
window.addEventListener('error', event => {
  console.error('异步错误:', event.message);
});

// 3. Promise 错误
window.addEventListener('unhandledrejection', event => {
  console.error('Promise 错误:', event.reason);
});

// 4. 资源错误（捕获阶段）
window.addEventListener('error', event => {
  const target = event.target;
  if (target && target.nodeName !== 'HTML') {
    console.error('资源错误:', target);
  }
}, true);

// 5. Vue 错误
app.config.errorHandler = (error, instance, info) => {
  console.error('Vue 错误:', error);
};
```

### Q2: window.onerror 和 addEventListener('error') 有什么区别？

**答案**：

**区别对比**：

| 特性 | window.onerror | addEventListener('error') |
|------|---------------|--------------------------|
| **同步错误** | ✅ 可以捕获 | ✅ 可以捕获 |
| **异步错误** | ❌ 不能捕获 | ✅ 可以捕获 |
| **资源错误** | ❌ 不能捕获 | ✅ 可以捕获（捕获阶段）|
| **Promise 错误** | ❌ 不能捕获 | ❌ 不能捕获 |
| **事件对象** | ❌ 没有 | ✅ 有 Event 对象 |
| **兼容性** | ✅ 所有浏览器 | ✅ 现代浏览器 |

**为什么需要两者？**

- `window.onerror` 可以捕获同步错误，但兼容性更好
- `addEventListener('error')` 可以捕获异步错误和资源错误
- 两者结合使用，可以捕获所有类型的错误

### Q3: 如何捕获 Promise 错误？为什么需要单独处理？

**答案**：

**捕获方式**：

```typescript
window.addEventListener('unhandledrejection', event => {
  const error = event.reason;
  let message = 'Unhandled Promise Rejection';
  
  if (error instanceof Error) {
    message = error.message;
  } else if (typeof error === 'string') {
    message = error;
  }
  
  console.error('Promise 错误:', message);
});
```

**为什么需要单独处理？**

1. **window.onerror 不能捕获**：Promise 错误不会触发 `window.onerror`
2. **addEventListener('error') 不能捕获**：Promise 错误不会触发 `error` 事件
3. **需要专门的事件**：必须使用 `unhandledrejection` 事件

**常见场景**：

```typescript
// 场景 1：未处理的 Promise 拒绝
Promise.reject(new Error('未处理的错误'));

// 场景 2：async/await 未捕获的错误
async function test() {
  throw new Error('async 错误');
}
test(); // 未使用 try-catch

// 场景 3：Promise 链中未处理的错误
fetch('/api/data')
  .then(res => res.json())
  .then(data => {
    throw new Error('处理错误');
  }); // 未使用 catch
```

### Q4: 如何捕获资源加载错误？为什么使用捕获阶段？

**答案**：

**捕获方式**：

```typescript
window.addEventListener('error', event => {
  const target = event.target;
  
  // 检查是否是资源加载错误
  if (target && target.nodeName !== 'HTML' && target.nodeName !== 'BODY') {
    const resourceType = target.nodeName.toLowerCase();
    const resourceUrl = (target as any).src || (target as any).href;
    
    console.error('资源加载错误:', resourceType, resourceUrl);
  }
}, true); // 使用捕获阶段
```

**为什么使用捕获阶段？**

1. **资源错误不冒泡**：资源错误不会冒泡到 window
2. **必须在捕获阶段捕获**：如果使用冒泡阶段，无法捕获资源错误
3. **更早捕获**：捕获阶段可以更早捕获错误

**资源类型**：

- `img`：图片加载错误
- `script`：脚本加载错误
- `link`：样式表加载错误
- `iframe`：iframe 加载错误

### Q5: 如何捕获 Vue 组件错误？捕获了哪些信息？

**答案**：

**捕获方式**：

```typescript
app.config.errorHandler = (error: Error, instance: any, info: string) => {
  const errorInfo = {
    type: ErrorType.VUE,
    message: error.message,
    stack: error.stack,
    componentName: instance?.$options?.name || 'Unknown',
    componentStack: info,
    propsData: instance?.$props,
    route: instance?.$route?.path,
    routeParams: instance?.$route?.params,
    routeQuery: instance?.$route?.query
  };
  
  errorCollector.collect(errorInfo);
};
```

**捕获的信息**：

- ✅ **错误信息**：错误消息和堆栈
- ✅ **组件名称**：发生错误的组件名称
- ✅ **组件堆栈**：Vue 组件调用堆栈
- ✅ **Props 数据**：组件的 props 数据
- ✅ **路由信息**：当前路由路径、参数、查询参数

**捕获范围**：

- 组件渲染错误
- 生命周期钩子错误
- 事件处理函数错误
- 自定义指令错误

### Q6: 如何捕获 HTTP 请求错误？Axios 拦截器如何工作？

**答案**：

**捕获方式**：

```typescript
// 请求拦截器
axiosInstance.interceptors.request.use(
  config => {
    config._requestStartTime = Date.now();
    return config;
  },
  error => {
    // 请求配置错误
    reportError(error);
    return Promise.reject(error);
  }
);

// 响应拦截器
axiosInstance.interceptors.response.use(
  response => response,
  error => {
    // 响应错误
    const errorInfo = {
      type: ErrorType.AJAX,
      message: error.message,
      requestUrl: error.config?.url,
      requestMethod: error.config?.method,
      responseStatus: error.response?.status,
      responseData: error.response?.data
    };
    
    reportError(errorInfo);
    return Promise.reject(error);
  }
);
```

**拦截器工作流程**：

```
发起请求
    ↓
请求拦截器（before）
    ↓
发送请求
    ↓
收到响应
    ↓
响应拦截器（success / error）
    ↓
返回数据 / 错误
```

**捕获的错误类型**：

- 网络错误（网络断开、超时）
- HTTP 错误（404、500 等）
- 请求配置错误
- 响应解析错误

### Q7: 如何实现错误去重？去重算法是什么？

**答案**：

**去重原理**：

使用错误的关键信息生成唯一 ID，相同错误生成相同 ID。

**生成算法**：

```typescript
private generateErrorId(errorInfo: ErrorInfo): string {
  // 使用错误类型、消息、文件名、行号生成唯一 ID
  const key = `${errorInfo.type}_${errorInfo.message}_${errorInfo.filename}_${errorInfo.lineno}`;
  
  // Base64 编码
  return btoa(key)
    .replace(/[^a-zA-Z0-9]/g, '')
    .substr(0, 16);
}
```

**去重逻辑**：

- **相同错误**：类型、消息、文件名、行号相同 → 相同 ID
- **不同错误**：任意一项不同 → 不同 ID

**去重优势**：

- ✅ **减少重复**：相同错误只记录一次
- ✅ **统计准确**：可以统计错误出现次数
- ✅ **节省存储**：减少数据库存储空间

### Q8: 如何过滤错误？过滤规则是什么？

**答案**：

**过滤机制**：

```typescript
private shouldIgnoreError(errorInfo: ErrorInfo): boolean {
  const { ignoreErrors = [], ignoreUrls = [] } = this.config;
  
  // 检查错误消息
  if (ignoreErrors.length > 0) {
    const shouldIgnore = ignoreErrors.some(pattern => {
      if (typeof pattern === 'string') {
        return errorInfo.message.includes(pattern);
      }
      return pattern.test(errorInfo.message);
    });
    if (shouldIgnore) return true;
  }
  
  // 检查URL
  if (ignoreUrls.length > 0) {
    const shouldIgnore = ignoreUrls.some(pattern => {
      if (typeof pattern === 'string') {
        return errorInfo.url.includes(pattern);
      }
      return pattern.test(errorInfo.url);
    });
    if (shouldIgnore) return true;
  }
  
  return false;
}
```

**过滤规则**：

1. **错误消息过滤**：可以配置字符串或正则表达式
2. **URL 过滤**：可以配置字符串或正则表达式

**使用示例**：

```typescript
setupErrorMonitor({
  ignoreErrors: [
    'Script error', // 忽略第三方脚本错误
    /ResizeObserver loop limit exceeded/ // 忽略 ResizeObserver 错误
  ],
  ignoreUrls: [
    /chrome-extension/, // 忽略浏览器扩展错误
    /moz-extension/,
    /safari-extension/
  ]
});
```

### Q9: 为什么要使用批量上报？如何实现？

**答案**：

**为什么使用批量上报？**

1. **减少请求数**：10 条错误合并为 1 个请求，减少 90% 请求数
2. **提高效率**：减少网络开销，提高上报效率
3. **降低服务器压力**：减少服务器处理请求的压力
4. **节省带宽**：减少 HTTP 请求头开销

**实现原理**：

```typescript
// 1. 初始化队列
const batchReportQueue = {
  queue: [],
  timer: null,
  config: {
    batchSize: 10,        // 达到 10 条立即上报
    batchInterval: 120000 // 120 秒超时上报
  }
};

// 2. 添加数据到队列
function addToBatchQueue(errorInfo) {
  batchReportQueue.queue.push(errorInfo);
  
  // 达到批量大小，立即上报
  if (batchReportQueue.queue.length >= batchReportQueue.config.batchSize) {
    flushBatchReport();
    return;
  }
  
  // 设置定时器，超时后自动上报
  if (batchReportQueue.timer === null) {
    batchReportQueue.timer = setTimeout(() => {
      flushBatchReport();
    }, batchReportQueue.config.batchInterval);
  }
}

// 3. 执行批量上报
async function flushBatchReport() {
  const dataToReport = [...batchReportQueue.queue];
  batchReportQueue.queue = [];
  
  await fetch(reportUrl, {
    method: 'POST',
    body: JSON.stringify({
      batch: dataToReport,
      batchSize: dataToReport.length,
      batchTimestamp: Date.now()
    })
  });
}
```

### Q10: 页面卸载时如何确保错误数据不丢失？

**答案**：

**使用 sendBeacon API**：

```typescript
window.addEventListener('beforeunload', () => {
  if (batchReportQueue.queue.length > 0) {
    const data = JSON.stringify({
      batch: batchReportQueue.queue,
      batchSize: batchReportQueue.queue.length,
      batchTimestamp: Date.now()
    });
    
    // 使用 sendBeacon 确保数据不丢失
    navigator.sendBeacon(reportUrl, data);
  }
});
```

**sendBeacon 的优势**：

- ✅ **可靠性高**：即使页面卸载也能发送数据
- ✅ **不阻塞**：异步发送，不阻塞页面卸载
- ✅ **自动重试**：浏览器自动处理网络问题
- ✅ **优先级高**：浏览器优先处理 sendBeacon 请求

**其他方案**：

- **visibilitychange 事件**：页面隐藏时上报
- **同步 XMLHttpRequest**：阻塞页面卸载（不推荐）
- **localStorage**：存储到本地，下次加载时上报

### Q11: 如何区分不同类型的错误？错误级别如何设置？

**答案**：

**错误类型**：

1. **JavaScript 错误**：同步和异步 JavaScript 错误
2. **Vue 错误**：Vue 组件错误
3. **Promise 错误**：未处理的 Promise 拒绝
4. **资源错误**：资源加载失败
5. **Ajax 错误**：HTTP 请求错误
6. **自定义错误**：手动上报的错误

**错误级别**：

```typescript
enum ErrorLevel {
  LOW = 'low',        // 低级：自定义错误
  MEDIUM = 'medium',  // 中级：Promise、资源、Ajax 错误
  HIGH = 'high',      // 高级：JavaScript、Vue 错误
  CRITICAL = 'critical' // 严重：影响核心功能
}
```

**默认级别配置**：

```typescript
levelConfig: {
  [ErrorType.JAVASCRIPT]: ErrorLevel.HIGH,
  [ErrorType.VUE]: ErrorLevel.HIGH,
  [ErrorType.PROMISE]: ErrorLevel.MEDIUM,
  [ErrorType.RESOURCE]: ErrorLevel.MEDIUM,
  [ErrorType.AJAX]: ErrorLevel.MEDIUM,
  [ErrorType.CUSTOM]: ErrorLevel.LOW
}
```

### Q12: 如何优化错误监控对页面性能的影响？

**答案**：

**优化措施**：

1. **异步处理**：错误收集和上报都是异步的，不阻塞主线程
2. **批量上报**：减少请求数，降低网络开销
3. **采样率控制**：可以设置采样率，只监控部分用户
4. **错误过滤**：过滤掉不重要的错误，减少上报量
5. **延迟上报**：使用 requestIdleCallback 在空闲时上报

**实现代码**：

```typescript
// 1. 采样率控制
if (Math.random() > (this.config.sampleRate || 1)) {
  return; // 不上报
}

// 2. 错误过滤
if (this.shouldIgnoreError(errorInfo)) {
  return; // 忽略错误
}

// 3. 延迟上报
if ('requestIdleCallback' in window) {
  requestIdleCallback(() => {
    this.reportError(errorInfo);
  });
} else {
  setTimeout(() => {
    this.reportError(errorInfo);
  }, 0);
}
```

---

## 最佳实践建议

### 1. 错误类型选择

**必须监控**：

- ✅ JavaScript 错误
- ✅ Vue 错误（Vue 项目）
- ✅ Promise 错误
- ✅ Ajax 错误

**建议监控**：

- ✅ 资源错误
- ✅ 自定义错误

### 2. 错误过滤配置

**建议过滤的错误**：

```typescript
ignoreErrors: [
  'Script error', // 第三方脚本错误（跨域）
  /ResizeObserver loop limit exceeded/, // ResizeObserver 错误
  /Non-Error promise rejection captured/ // 非 Error 对象的 Promise 拒绝
],
ignoreUrls: [
  /chrome-extension/, // 浏览器扩展
  /moz-extension/,
  /safari-extension/
]
```

### 3. 批量上报配置

**推荐配置**：

```typescript
batchConfig: {
  enabled: true,
  batchSize: 10,        // 达到 10 条立即上报
  batchInterval: 120000  // 120 秒超时上报
}
```

### 4. 采样率配置

**生产环境**：

```typescript
sampleRate: process.env.NODE_ENV === 'production' ? 0.1 : 1.0
// 生产环境 10% 采样率，开发环境 100% 采样率
```

### 5. 错误级别设置

**建议配置**：

- **CRITICAL**：影响核心功能的错误
- **HIGH**：JavaScript、Vue 错误
- **MEDIUM**：Promise、资源、Ajax 错误
- **LOW**：自定义错误、业务逻辑错误

### 6. 数据存储建议

**建议存储字段**：

- 错误类型（type）
- 错误消息（message）
- 错误堆栈（stack）
- 错误级别（level）
- 时间戳（timestamp）
- URL（url）
- 用户代理（userAgent）
- 错误ID（errorId，用于去重）

---

## 总结

前端错误监控是前端工程化的重要组成部分，通过监控各种类型的错误，可以帮助开发者：

### 核心价值

1. ✅ **快速定位问题**：及时发现和定位生产环境错误
2. ✅ **提升用户体验**：减少错误对用户体验的影响
3. ✅ **优化代码质量**：通过错误分析指导代码优化
4. ✅ **业务价值**：降低错误率，提升业务指标

### 技术要点

1. ✅ **全面捕获**：使用多种方式捕获所有类型的错误
2. ✅ **错误过滤**：过滤掉不重要的错误
3. ✅ **错误去重**：使用 errorId 去重，减少重复
4. ✅ **批量上报**：提高上报效率
5. ✅ **可靠上报**：使用 sendBeacon 确保数据不丢失

### 监控类型

- **JavaScript 错误**：同步和异步错误
- **Vue 错误**：组件错误
- **Promise 错误**：未处理的 Promise 拒绝
- **资源错误**：资源加载失败
- **Ajax 错误**：HTTP 请求错误
- **自定义错误**：手动上报的错误

通过合理使用这些技术，可以构建一个完整、高效的前端错误监控系统。

