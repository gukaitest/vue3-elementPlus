# 虚拟滚动列表性能优化原理详解

**实现原理**：

- 监听下拉框的滚动事件
- 当滚动到底部时（`scrollHeight <= scrollTop + clientHeight`）
  - `scrollHeight`: 元素内容的总高度（包括不可见部分），即整个可滚动内容的高度
  - `scrollTop`(跟着滚动一直在变的指): 元素顶部被滚动隐藏的距离，即当前滚动位置距离内容顶部的像素值
  - `clientHeight`: 元素可见区域的高度（不包括滚动条），即视口高度
- 且还有更多数据时（`total > pageNo * pageSize`）
- 自动加载下一页数据
  scrollTop，startIndex，endIndex的计算

## 目录

1. [概述](#概述)
2. [虚拟滚动的核心原理](#虚拟滚动的核心原理)
3. [ElSelectV2 组件实现机制](#elselectv2-组件实现机制)
4. [性能优化原理深度解析](#性能优化原理深度解析)
5. [代码实现分析](#代码实现分析)
6. [与传统列表的对比](#与传统列表的对比)
7. [最佳实践与注意事项](#最佳实践与注意事项)
8. [性能监控与评估](#性能监控与评估)

---

## 概述

在 `src/views/personal-content/select-optimization/index.vue` 文件的第168行，使用了 Element Plus 的 `ElSelectV2` 组件来实现虚拟滚动选择器。虚拟滚动（Virtual Scrolling）是一种前端性能优化技术，通过只渲染可见区域内的 DOM 元素来大幅提升大数据量列表的渲染性能。

### 为什么需要虚拟滚动？

当处理大量数据（如数千甚至数万条记录）时，传统的列表渲染方式会：

- **创建大量 DOM 节点**：每个数据项都对应一个 DOM 元素
- **占用大量内存**：所有 DOM 节点都保存在内存中
- **导致渲染卡顿**：浏览器需要处理大量 DOM 操作
- **滚动性能差**：滚动时需要重排和重绘大量元素

虚拟滚动通过**按需渲染**的方式，从根本上解决了这些问题。

---

## 虚拟滚动的核心原理

### 1. 基本概念

虚拟滚动的核心思想是：**只渲染用户当前可见的列表项，而不是渲染整个列表**。

```
┌─────────────────────────────────┐
│  可视区域 (Viewport)              │
│  ┌───────────────────────────┐  │
│  │  可见项 1                  │  │ ← 实际渲染的 DOM
│  │  可见项 2                  │  │
│  │  可见项 3                  │  │
│  │  ...                      │  │
│  │  可见项 N                  │  │
│  └───────────────────────────┘  │
│                                  │
│  ↑ 上方占位符 (padding-top)      │ ← 空白占位，不渲染 DOM
│                                  │
│  ↓ 下方占位符 (padding-bottom)   │ ← 空白占位，不渲染 DOM
└─────────────────────────────────┘
```

### 2. 关键计算参数

虚拟滚动需要计算以下关键参数：

#### 2.1 可视区域高度 (Viewport Height)

```javascript
const viewportHeight = container.clientHeight; // 容器可见高度
```

#### 2.2 每个列表项的高度 (Item Height)

```javascript
const itemHeight = 34; // 假设每个选项高度为 34px
// 或者动态计算：itemHeight = item.offsetHeight
```

#### 2.3 可见项数量 (Visible Items Count)

```javascript
const visibleCount = Math.ceil(viewportHeight / itemHeight) + 2; // +2 作为缓冲区
```

#### 2.4 滚动偏移量 (Scroll Offset)

```javascript
const scrollTop = container.scrollTop; // 当前滚动位置
```

#### 2.5 起始索引 (Start Index)

```javascript
const startIndex = Math.floor(scrollTop / itemHeight);
```

#### 2.6 结束索引 (End Index)

```javascript
const endIndex = Math.min(startIndex + visibleCount, totalItems);
```

#### 2.7 占位符高度

```javascript
const paddingTop = startIndex * itemHeight; // 上方占位符
const paddingBottom = (totalItems - endIndex) * itemHeight; // 下方占位符
```

### 3. 渲染流程

```
1. 监听滚动事件
   ↓
2. 计算当前滚动位置 (scrollTop)
   ↓
3. 计算可见项的起始索引和结束索引
   ↓
4. 只渲染 [startIndex, endIndex] 范围内的数据项
   ↓
5. 设置上方和下方的占位符高度，保持总高度不变
   ↓
6. 更新 DOM（只更新变化的部分）
```

---

## ElSelectV2 组件实现机制

### 1. 组件特性

`ElSelectV2` 是 Element Plus 提供的虚拟滚动选择器组件，基于虚拟滚动技术实现。主要特性包括：

- ✅ **虚拟滚动**：自动处理大量数据的渲染优化
- ✅ **远程搜索**：支持 `remote-method` 进行远程数据加载
- ✅ **多选支持**：支持 `multiple` 模式
- ✅ **标签折叠**：支持 `collapse-tags` 折叠已选标签
- ✅ **防抖搜索**：配合 `useDebounceFn` 实现搜索防抖

### 2. 核心实现原理

Element Plus 的 `ElSelectV2` 内部实现大致如下：

```typescript
// 伪代码示例
class ElSelectV2 {
  // 虚拟滚动核心逻辑
  handleScroll(event: Event) {
    const scrollTop = this.scrollContainer.scrollTop;
    const viewportHeight = this.scrollContainer.clientHeight;

    // 计算可见范围
    const startIndex = Math.floor(scrollTop / this.itemHeight);
    const endIndex = Math.min(
      startIndex + Math.ceil(viewportHeight / this.itemHeight) + 2,
      this.options.length,
    );

    // 只渲染可见项
    this.visibleOptions = this.options.slice(startIndex, endIndex);

    // 设置占位符
    this.paddingTop = startIndex * this.itemHeight;
    this.paddingBottom = (this.options.length - endIndex) * this.itemHeight;
  }
}
```

### 3. 与普通 ElSelect 的区别

| 特性       | ElSelect          | ElSelectV2                |
| ---------- | ----------------- | ------------------------- |
| 渲染方式   | 渲染所有选项      | 只渲染可见选项            |
| 性能       | 数据量大时卡顿    | 流畅，支持万级数据        |
| DOM 节点数 | 等于数据量        | 等于可见项数（通常 < 20） |
| 内存占用   | 高                | 低                        |
| 适用场景   | 少量数据（< 100） | 大量数据（> 100）         |

---

## 性能优化原理深度解析

### 1. DOM 节点数量优化

#### 传统方式

```javascript
// 假设有 10,000 条数据
const options = Array.from({ length: 10000 }, (_, i) => ({
  value: i,
  label: `选项 ${i}`,
}));

// 传统渲染：创建 10,000 个 DOM 节点
// <div>选项 0</div>
// <div>选项 1</div>
// ...
// <div>选项 9999</div>
// 总计：10,000 个 DOM 节点
```

#### 虚拟滚动方式

```javascript
// 虚拟滚动：只创建可见的节点（假设可见区域显示 10 个）
// <div style="height: 0px"></div>  ← 上方占位符（无 DOM）
// <div>选项 100</div>              ← 实际渲染
// <div>选项 101</div>
// ...
// <div>选项 109</div>
// <div style="height: 336600px"></div>  ← 下方占位符（无 DOM）
// 总计：10 个 DOM 节点
```

**性能提升**：DOM 节点数量从 10,000 减少到 10，减少了 **99.9%**。

### 2. 内存占用优化

#### 内存占用对比

```
传统方式：
- DOM 节点内存：10,000 × 平均 2KB = 20MB
- 事件监听器：10,000 个
- 总内存：~25MB

虚拟滚动：
- DOM 节点内存：10 × 平均 2KB = 20KB
- 事件监听器：10 个
- 总内存：~50KB
```

**内存节省**：约 **99.8%**。

### 3. 渲染性能优化

#### 3.1 初始渲染时间

```
传统方式：
- 创建 10,000 个 DOM 节点：~500ms
- 布局计算（Layout）：~200ms
- 绘制（Paint）：~100ms
- 总计：~800ms

虚拟滚动：
- 创建 10 个 DOM 节点：~1ms
- 布局计算：~5ms
- 绘制：~2ms
- 总计：~8ms
```

**渲染速度提升**：约 **100 倍**。

#### 3.2 滚动性能

```
传统方式：
- 每次滚动触发所有节点的重排：~50ms
- FPS：~20fps（卡顿明显）

虚拟滚动：
- 只更新可见节点的位置：~2ms
- FPS：~60fps（流畅）
```

### 4. 滚动事件优化

虚拟滚动在滚动时只需要：

1. **计算新的可见范围**（O(1) 时间复杂度）
2. **更新少量 DOM 节点**（通常 < 20 个）
3. **调整占位符高度**（只更新样式，不创建/删除 DOM）

而传统方式需要：

1. **重排所有节点**（O(n) 时间复杂度）
2. **触发所有节点的重绘**

---

## 代码实现分析

### 1. 当前实现代码解析

让我们分析 `src/views/personal-content/select-optimization/index.vue` 中的关键代码：

#### 1.1 ElSelectV2 组件使用

```vue
<ElSelectV2
  v-model="value"
  popper-class="selectRef"
  class="m-6"
  :popper-append-to-body="false"
  multiple
  filterable
  remote
  collapse-tags
  :max-collapse-tags="3"
  :remote-method="debounceRemoteMethod"
  clearable
  :options="options"
  :loading="loading"
  placeholder="请输入关键字再选择"
  style="width: 240px"
  @focus="handleFocus"
/>
```

**关键属性说明**：

- `remote`: 启用远程搜索模式
- `remote-method`: 远程搜索方法（带防抖）
- `options`: 选项数据数组
- `multiple`: 多选模式
- `collapse-tags`: 折叠标签显示

#### 1.2 远程搜索实现

```typescript
const remoteMethod = async (query: string) => {
  filterInput.value = query;
  params.pageNo = 1;
  params.pageSize = 50;
  options.value.splice(0, options.value.length); // 清空旧数据

  await getOptionData(); // 加载新数据

  setTimeout(() => {
    handleFocus(); // 绑定滚动事件
  }, 2000);
};

const debounceRemoteMethod = useDebounceFn(remoteMethod, 500);
```

**优化点**：

- ✅ 使用 `useDebounceFn` 防抖，避免频繁请求
- ✅ 分页加载（pageSize: 50），控制单次数据量
- ✅ 清空旧数据，避免内存泄漏

#### 1.3 滚动加载更多

```typescript
const handleScroll = () => {
  if (element.value) {
    const loadMore =
      // scrollHeight: 元素内容的总高度（包括不可见部分）
      // clientHeight: 元素可见区域的高度（不包括滚动条）
      // scrollTop: 元素顶部被滚动隐藏的距离
      element.value.scrollHeight <=
        element.value.clientHeight + element.value.scrollTop + 0 &&
      params.total > params.pageNo * params.pageSize;

    if (loadMore) {
      params.pageNo += 1;
      getOptionData(); // 加载下一页
    }
  }
};
```

**实现原理**：

- 监听下拉框的滚动事件
- 当滚动到底部时（`scrollHeight <= scrollTop + clientHeight`）
  - `scrollHeight`: 元素内容的总高度（包括不可见部分），即整个可滚动内容的高度
  - `scrollTop`: 元素顶部被滚动隐藏的距离，即当前滚动位置距离内容顶部的像素值
  - `clientHeight`: 元素可见区域的高度（不包括滚动条），即视口高度
- 且还有更多数据时（`total > pageNo * pageSize`）
- 自动加载下一页数据

### 2. 虚拟滚动的内部工作流程

```
用户输入搜索关键词
    ↓
触发 debounceRemoteMethod（防抖 500ms）
    ↓
调用 remoteMethod
    ↓
清空 options，重置分页参数
    ↓
调用 getOptionData() 获取第一页数据（50条）
    ↓
ElSelectV2 接收新数据
    ↓
【虚拟滚动核心】只渲染可见的选项（约 10-15 个）
    ↓
用户滚动下拉框
    ↓
ElSelectV2 内部：
  1. 计算新的可见范围
  2. 更新可见项的 DOM
  3. 调整占位符高度
    ↓
滚动到底部时，触发 handleScroll
    ↓
加载下一页数据（pageNo += 1）
    ↓
追加到 options 数组
    ↓
ElSelectV2 自动更新虚拟列表
```

---

## 与传统列表的对比

### 1. 性能对比表

| 指标         | 传统列表（10,000 条） | 虚拟滚动（10,000 条） | 提升倍数 |
| ------------ | --------------------- | --------------------- | -------- |
| DOM 节点数   | 10,000                | ~15                   | 666x     |
| 初始渲染时间 | ~800ms                | ~8ms                  | 100x     |
| 内存占用     | ~25MB                 | ~50KB                 | 500x     |
| 滚动 FPS     | ~20fps                | ~60fps                | 3x       |
| 滚动延迟     | ~50ms                 | ~2ms                  | 25x      |

### 2. 实际场景对比

#### 场景 1：100 条数据

- **传统方式**：流畅，无明显差异
- **虚拟滚动**：流畅，略有开销（计算可见范围）
- **建议**：使用传统方式

#### 场景 2：1,000 条数据

- **传统方式**：开始卡顿，初始渲染 ~80ms
- **虚拟滚动**：流畅，初始渲染 ~8ms
- **建议**：使用虚拟滚动

#### 场景 3：10,000 条数据

- **传统方式**：严重卡顿，初始渲染 ~800ms，可能白屏
- **虚拟滚动**：流畅，初始渲染 ~8ms
- **建议**：必须使用虚拟滚动

### 3. 适用场景判断

```
数据量 < 100    → 使用 ElSelect（传统方式）
数据量 100-500  → 根据实际情况选择
数据量 > 500    → 必须使用 ElSelectV2（虚拟滚动）
```

---

## 最佳实践与注意事项

### 1. 数据加载策略

#### ✅ 推荐：分页加载 + 虚拟滚动

```typescript
// 好的实践
const params = reactive({
  pageNo: 1,
  pageSize: 50, // 每页 50 条
  total: 0,
});

const getOptionData = async () => {
  const res = await fetchData({
    pageNo: params.pageNo,
    pageSize: params.pageSize,
  });

  // 追加数据，而不是替换
  options.value.push(...res.data.list);
  params.total = res.data.total;
};
```

#### ❌ 不推荐：一次性加载所有数据

```typescript
// 不好的实践
const getAllData = async () => {
  const res = await fetchAllData(); // 一次性加载 10,000 条
  options.value = res.data; // 虽然虚拟滚动能处理，但网络传输慢
};
```

### 2. 防抖优化

```typescript
// ✅ 使用防抖，避免频繁请求
const debounceRemoteMethod = useDebounceFn(remoteMethod, 500);

// ❌ 不使用防抖，每次输入都请求
const remoteMethod = async (query: string) => {
  // 直接请求，可能导致请求风暴
};
```

### 3. 内存管理

```typescript
// ✅ 及时清理数据
onUnmounted(() => {
  options.value = []; // 清空数据
  window.removeEventListener("web-vitals", handleWebVitalsEvent);
});

// ✅ 滚动加载时控制总量
if (options.value.length > 1000) {
  // 可以移除最早的数据，保持列表在合理范围
  options.value = options.value.slice(-500);
}
```

### 4. 事件监听优化

```typescript
// ✅ 在适当时机绑定事件
const handleFocus = () => {
  element.value = document.querySelector(
    ".selectRef .el-select-dropdown__list",
  );
  if (element.value) {
    element.value.addEventListener("scroll", handleScroll);
  }
};

// ✅ 组件卸载时移除事件
onUnmounted(() => {
  if (element.value) {
    element.value.removeEventListener("scroll", handleScroll);
  }
});
```

### 5. 性能监控

当前代码中已经集成了 FPS 监控：

```typescript
// FPS 监控配置
const fpsConfig = {
  enableConsoleLog: true,
  enableReport: true,
  thresholds: {
    fps: 30, // 30fps 作为基准
  },
};

// 在数据加载时启动监控
startFPSMonitor(fpsConfig);
```

**建议**：

- 监控初始渲染 FPS
- 监控滚动时的 FPS
- 监控数据加载时的 FPS
- 设置合理的阈值（如 30fps）

---

## 性能监控与评估

### 1. 关键性能指标（KPI）

#### 1.1 初始渲染时间

```javascript
console.time("select-render");
// ... 渲染逻辑
console.timeEnd("select-render");
// 目标：< 50ms
```

#### 1.2 FPS（帧率）

```javascript
// 使用当前代码中的 FPS 监控
startFPSMonitor({
  thresholds: { fps: 30 },
});
// 目标：> 30fps（流畅），理想：60fps
```

#### 1.3 DOM 节点数

```javascript
const domCount = document.querySelectorAll(".el-select-dropdown__item").length;
console.log("DOM 节点数:", domCount);
// 目标：< 20（只渲染可见项）
```

#### 1.4 内存占用

```javascript
// 使用 Performance API
const memory = performance.memory;
console.log("内存占用:", {
  used: (memory.usedJSHeapSize / 1048576).toFixed(2) + "MB",
  total: (memory.totalJSHeapSize / 1048576).toFixed(2) + "MB",
});
```

### 2. 性能测试场景

#### 场景 1：小数据量（100 条）

- 预期：初始渲染 < 10ms，FPS > 60
- 实际测试：...

#### 场景 2：中等数据量（1,000 条）

- 预期：初始渲染 < 20ms，FPS > 50
- 实际测试：...

#### 场景 3：大数据量（10,000 条）

- 预期：初始渲染 < 50ms，FPS > 30
- 实际测试：...

### 3. 优化建议

如果性能不达标，可以考虑：

1. **减少单次加载数据量**

   ```typescript
   pageSize: 30; // 从 50 减少到 30
   ```

2. **增加防抖时间**

   ```typescript
   useDebounceFn(remoteMethod, 800); // 从 500ms 增加到 800ms
   ```

3. **使用 Web Worker 处理数据**

   ```typescript
   // 在 Worker 中处理数据转换
   const worker = new Worker("data-processor.js");
   ```

4. **虚拟化优化**
   - 确保每个选项高度固定（或可计算）
   - 避免在选项中使用复杂组件

---

## 总结

虚拟滚动通过**只渲染可见区域**的核心思想，实现了：

1. **DOM 节点数量减少 99%+**：从数千个减少到十几个
2. **内存占用减少 99%+**：从数十 MB 减少到几十 KB
3. **渲染速度提升 100 倍**：从数百毫秒减少到几毫秒
4. **滚动性能提升 3 倍**：从 20fps 提升到 60fps

`ElSelectV2` 组件封装了这些优化，使得开发者可以轻松处理大量数据的选择场景，而无需关心底层的虚拟滚动实现细节。

### 关键要点

- ✅ **数据量 > 500 时，必须使用虚拟滚动**
- ✅ **配合分页加载，避免一次性加载过多数据**
- ✅ **使用防抖优化搜索请求**
- ✅ **及时清理数据和事件监听器**
- ✅ **监控性能指标，持续优化**

---

## 参考资料

- [Element Plus SelectV2 官方文档](https://element-plus.org/en-US/component/select-v2.html)
- [Virtual Scrolling 原理详解](https://web.dev/virtualize-long-lists-react-window/)
- [Vue 3 性能优化指南](https://vuejs.org/guide/best-practices/performance.html)

---

**文档生成时间**：2024年
**适用版本**：Vue 3 + Element Plus
**维护者**：开发团队

# 手动实现一个前端虚拟滚动列表

你希望手动实现一个前端虚拟滚动列表，核心目标是针对长列表场景，只渲染当前可视区域内的列表项（而非全部数据），以此大幅提升页面的渲染性能和滚动流畅度。

### 实现思路

虚拟滚动的核心是「可视区域渲染 + 占位撑高」，具体逻辑如下：

1. **结构设计**：外层滚动容器（固定高度、可滚动），内部包含「占位容器」（撑起列表总高度，保证滚动条正常）和「内容容器」（仅渲染可视区域的列表项，通过 `transform` 定位）；
2. **核心计算**：根据滚动容器的滚动偏移量（`scrollTop`）、每项高度，计算当前需要渲染的列表项的**起始/结束索引**；
3. **滚动监听**：实时监听滚动事件，更新渲染的列表项和内容容器的偏移位置；
4. **缓存优化**：额外渲染少量「缓存项」（上下各n项），避免滚动时出现空白闪屏。

### 完整实现代码

以下是基于原生 HTML/CSS/JS 的极简版虚拟滚动列表（固定项高，新手易理解）：

```html
<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <title>手动实现虚拟滚动列表</title>
    <style>
      /* 核心样式 */
      .virtual-list {
        width: 300px;
        height: 500px; /* 可视区域高度 */
        border: 1px solid #e5e7eb;
        overflow: auto; /* 开启滚动 */
        position: relative; /* 作为子元素定位的参考 */
      }

      /* 占位容器：撑起整个列表的高度，保证滚动条正常 */
      .list-placeholder {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        /* 高度由JS动态计算（总项数 * 每项高度） */
      }

      /* 内容容器：仅渲染可视区域的项，通过transform定位 */
      .list-content {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
      }

      /* 列表项样式 */
      .list-item {
        height: 50px; /* 固定每项高度 */
        line-height: 50px;
        padding: 0 16px;
        border-bottom: 1px solid #f0f0f0;
        box-sizing: border-box;
      }
    </style>
  </head>
  <body>
    <div class="virtual-list" id="virtualList">
      <div class="list-placeholder" id="listPlaceholder"></div>
      <div class="list-content" id="listContent"></div>
    </div>

    <script>
      // 1. 核心配置
      const config = {
        itemHeight: 50, // 每项固定高度（px）
        visibleCount: 0, // 可视区域可显示的项数（动态计算）
        bufferCount: 2, // 上下缓存项数（避免滚动空白）
        totalCount: 10000, // 模拟1万条数据（长列表）
      };

      // 2. 获取DOM元素
      const virtualList = document.getElementById("virtualList");
      const listPlaceholder = document.getElementById("listPlaceholder");
      const listContent = document.getElementById("listContent");

      // 3. 生成模拟数据
      const generateData = (count) => {
        return Array.from({ length: count }, (_, index) => ({
          id: index + 1,
          text: `列表项 ${index + 1}`,
        }));
      };
      const listData = generateData(config.totalCount);

      // 4. 初始化
      const init = () => {
        // 计算可视区域可显示的项数
        config.visibleCount = Math.ceil(
          virtualList.clientHeight / config.itemHeight,
        );
        // 设置占位容器高度（总高度）
        listPlaceholder.style.height = `${config.totalCount * config.itemHeight}px`;
        // 首次渲染
        renderItems();
        // 监听滚动事件
        virtualList.addEventListener("scroll", handleScroll);
      };

      // 5. 处理滚动事件
      const handleScroll = () => {
        renderItems(); // 滚动时更新渲染的项
      };

      // 6. 计算需要渲染的索引范围
      const calculateRange = () => {
        // 滚动偏移量
        const scrollTop = virtualList.scrollTop;
        // 起始索引（减去缓存项，避免滚动空白）
        let startIndex =
          Math.floor(scrollTop / config.itemHeight) - config.bufferCount;
        // 结束索引（加上可视项数 + 缓存项）
        let endIndex =
          startIndex + config.visibleCount + 2 * config.bufferCount;

        // 边界处理（避免索引越界）
        startIndex = Math.max(0, startIndex);
        endIndex = Math.min(config.totalCount - 1, endIndex);

        return { startIndex, endIndex };
      };

      // 7. 渲染可视区域的列表项
      const renderItems = () => {
        const { startIndex, endIndex } = calculateRange();
        // 截取需要渲染的数据
        const visibleData = listData.slice(startIndex, endIndex + 1);
        // 渲染DOM
        listContent.innerHTML = visibleData
          .map(
            (item) => `
        <div class="list-item" data-id="${item.id}">
          ${item.text}
        </div>
      `,
          )
          .join("");
        // 更新内容容器的偏移位置（让渲染的项显示在正确位置）
        listContent.style.transform = `translateY(${startIndex * config.itemHeight}px)`;
      };

      // 启动初始化
      init();
    </script>
  </body>
</html>
```

### 关键代码解释

1. **容器结构**：

   - `.virtual-list`：滚动容器，固定高度并开启 `overflow: auto`；
   - `.list-placeholder`：占位容器，高度等于「总项数 × 每项高度」，目的是让滚动条的长度匹配真实长列表；
   - `.list-content`：仅渲染可视区域的项，通过 `transform: translateY()` 定位到滚动后的正确位置。

2. **核心计算（calculateRange）**：

   - `scrollTop`：滚动容器的垂直滚动距离；
   - `startIndex`：当前可视区域第一个项的索引（减去缓存项）；
   - `endIndex`：当前可视区域最后一个项的索引（加上缓存项）；
   - 边界处理：确保索引不会小于0或超过总项数。

3. **渲染逻辑（renderItems）**：
   - 截取 `startIndex` 到 `endIndex` 之间的数据，仅渲染这部分DOM；
   - 通过 `translateY` 让内容容器偏移到「起始索引 × 每项高度」的位置，保证视觉上和真实滚动位置一致。

### 扩展优化（可选）

- **动态项高**：如果列表项高度不固定，需要先预计算所有项的高度，或通过「预估高度 + 实际测量修正」实现；
- **节流优化**：滚动事件触发频率高，可加节流函数（如 `requestAnimationFrame`）减少计算次数；
- **复用DOM**：避免每次滚动都重新生成DOM，可维护一个DOM池，复用已创建的列表项节点。

### 总结

1. 虚拟滚动的核心是「只渲染可视区域 + 占位容器撑高度」，避免长列表生成大量DOM节点；
2. 关键计算是基于 `scrollTop` 和项高确定渲染的索引范围，边界处理和缓存项是提升体验的关键；
3. 固定项高是基础版实现，动态项高需额外处理高度计算和偏移修正。
