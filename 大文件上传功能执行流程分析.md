# 大文件上传功能 - 函数执行顺序分析

## 📋 整体流程图

```
用户选择文件
    ↓
handleUploadFile (入口函数)
    ↓
useWorker (计算文件Hash)
    ↓
checkFile (检查服务器文件)
    ↓
uploadSignleFile (开始上传)
    ↓
uploadChunk (上传单个切片) [循环]
    ↓
signleFileProgress (更新进度)
    ↓
handleMerge (合并切片)
    ↓
finishTask (标记完成)
```

---

## 🔄 详细执行顺序

### 1️⃣ **入口：文件选择事件**
**函数：`handleUploadFile`** (第276行)
- **触发时机**：用户通过 `<input type="file">` 选择文件时
- **执行步骤**：
  1. 验证文件是否存在
  2. 检查文件大小（限制100MB）
  3. 遍历每个文件，为每个文件创建上传任务

---

### 2️⃣ **文件初始化阶段**
**在 `handleUploadFile` 内部** (第298-331行)
- 为每个文件创建 `inTaskArrItem` 响应式对象
- 设置初始状态：`state = 0` → `state = 1` (文件处理中)
- 将文件添加到 `uploadFileList` 列表
- 检查文件大小是否为0，如果是则标记失败

---

### 3️⃣ **计算文件Hash**
**函数：`useWorker`** (第61-80行)
- **调用位置**：`handleUploadFile` 第342行
- **功能**：使用 Web Worker 在后台线程计算文件Hash值
- **返回**：`{ fileHash, fileChunkList }`
- **状态变化**：`state = 1` (处理中)

---

### 4️⃣ **检查服务器文件**
**API调用：`checkFile`** (第364行)
- **调用位置**：`handleUploadFile` 第364行
- **功能**：检查服务器是否已存在该文件（秒传功能）
- **返回结果处理**：
  - 如果 `shouldUpload = false`：调用 `finishTask` → 秒传完成
  - 如果 `shouldUpload = true`：继续上传流程
- **状态变化**：`state = 2` (上传中)

---

### 5️⃣ **准备切片列表**
**在 `handleUploadFile` 内部** (第378-420行)
- 将文件切片信息映射到 `allChunkList`
- 如果服务器已存在部分切片，过滤掉已上传的切片
- 如果所有切片都已上传但未合并，调用 `handleMerge`

---

### 6️⃣ **开始上传文件**
**函数：`uploadSignleFile`** (第163-265行)
- **调用位置**：
  - `handleUploadFile` 第423行（首次）
  - `uploadChunk` 第244行（递归调用，继续上传剩余切片）
  - `resumeUpload` 第273行（恢复上传）
- **执行逻辑**：
  1. 检查是否有待上传切片
  2. 动态计算并发数：`maxRequest = Math.ceil(6 / 正在上传文件数)`
  3. 从 `allChunkList` 取出最多 `maxRequest` 个切片
  4. 将切片添加到 `whileRequests`（正在上传列表）
  5. 循环调用 `uploadChunk` 上传每个切片

---

### 7️⃣ **上传单个切片**
**函数：`uploadChunk`** (第192-257行，定义在 `uploadSignleFile` 内部)
- **调用位置**：`uploadSignleFile` 第262行（循环调用）
- **执行逻辑**：
  1. 构建 FormData，包含切片信息
  2. 调用 `uploadFile` API 上传切片
  3. 注册取消函数到 `needObj.cancel`
  4. **上传成功**：
     - 更新 `finishNumber`
     - 调用 `signleFileProgress` 更新进度
     - 从 `whileRequests` 移除该切片
     - 如果所有切片完成 → 调用 `handleMerge`
     - 否则 → 递归调用 `uploadSignleFile` 继续上传
  5. **上传失败**：
     - `errNumber++`
     - 如果失败超过3次 → 调用 `pauseUpload(taskArrItem, false)` 中断上传
     - 否则 → 递归调用 `uploadChunk` 重试

---

### 8️⃣ **更新上传进度**
**函数：`signleFileProgress`** (第129-132行)
- **调用位置**：`uploadChunk` 第238行
- **功能**：计算并更新文件上传百分比
- **公式**：`percentage = (finishNumber / chunkNumber) * 100`

---

### 9️⃣ **合并切片**
**函数：`handleMerge`** (第141-161行)
- **调用位置**：
  - `uploadChunk` 第242行（所有切片上传完成）
  - `handleUploadFile` 第410行（切片已存在但未合并）
- **执行逻辑**：
  1. 调用 `mergeChunk` API 合并所有切片
  2. **合并成功**：调用 `finishTask` 标记完成
  3. **合并失败**：调用 `pauseUpload(taskArrItem, true)` 暂停上传
  4. 重置 `finishNumber = 0`

---

### 🔟 **标记上传完成**
**函数：`finishTask`** (第135-139行)
- **调用位置**：
  - `handleMerge` 第152行（合并成功）
  - `handleUploadFile` 第373行（秒传成功）
- **功能**：
  - 设置 `percentage = 100`
  - 设置 `state = 4` (上传完成)

---

## 🎛️ 控制函数（用户操作）

### ⏸️ **暂停上传**
**函数：`pauseUpload`** (第83-110行)
- **调用位置**：
  - 用户点击暂停按钮（通过 `@pause-upload` 事件）
  - `uploadChunk` 第229行（失败超过3次，自动中断）
  - `handleMerge` 第156行（合并失败）
- **功能**：
  - 设置状态：`state = 3` (暂停) 或 `state = 5` (中断)
  - 取消所有正在进行的请求（调用每个切片的 `cancel` 函数）

---

### ▶️ **继续上传**
**函数：`resumeUpload`** (第267-274行)
- **调用位置**：用户点击继续按钮（通过 `@resume-upload` 事件）
- **功能**：
  - 设置 `state = 2` (上传中)
  - 将 `whileRequests` 中的切片移回 `allChunkList`
  - 调用 `uploadSignleFile` 继续上传

---

### ❌ **取消单个文件**
**函数：`cancelSingle`** (第113-117行)
- **调用位置**：用户点击取消按钮（通过 `@cancel-single` 事件）
- **功能**：
  - 调用 `pauseUpload` 暂停上传
  - 从 `uploadFileList` 中移除该文件

---

### ❌ **取消所有文件**
**函数：`cancelAll`** (第120-126行)
- **调用位置**：用户点击"全部取消"按钮
- **功能**：
  - 遍历所有文件，调用 `pauseUpload`
  - 清空 `uploadFileList`

---

## 📊 状态说明

| 状态值 | 含义 | 说明 |
|--------|------|------|
| 0 | 初始状态 | 什么都不做 |
| 1 | 文件处理中 | 正在计算Hash |
| 2 | 上传中 | 正在上传切片 |
| 3 | 暂停 | 用户主动暂停 |
| 4 | 上传完成 | 所有切片上传并合并成功 |
| 5 | 上传中断 | 失败超过3次或合并失败 |
| 6 | 上传失败 | 文件检查失败或文件大小为0 |

---

## 🔁 递归调用链

### 正常上传流程（递归）
```
uploadSignleFile
    ↓
uploadChunk (并发多个)
    ↓
[切片上传成功]
    ↓
uploadSignleFile (递归，继续上传剩余切片)
    ↓
uploadChunk
    ↓
...
    ↓
[所有切片完成]
    ↓
handleMerge
    ↓
finishTask
```

### 失败重试流程（递归）
```
uploadChunk
    ↓
[上传失败，errNumber < 3]
    ↓
uploadChunk (递归重试)
    ↓
[成功或失败超过3次]
```

---

## 🎯 关键数据流

### `allChunkList` (待上传切片列表)
- **初始化**：`handleUploadFile` 第378行
- **减少**：`uploadSignleFile` 第185行（取出切片）
- **增加**：`resumeUpload` 第271行（恢复上传时）

### `whileRequests` (正在上传切片列表)
- **增加**：`uploadSignleFile` 第181行
- **减少**：`uploadChunk` 第239行（切片上传完成）

### `finishNumber` (已完成切片数)
- **增加**：`uploadChunk` 第236行（切片上传成功）
- **重置**：`handleMerge` 第160行（合并后重置为0）

---

## ⚠️ 注意事项

1. **并发控制**：浏览器同域名最大并发6个请求，会根据同时上传的文件数动态分配
2. **错误重试**：单个切片失败会重试，超过3次失败会中断整个文件上传
3. **秒传机制**：通过文件Hash判断，如果服务器已存在完整文件，直接标记完成
4. **断点续传**：通过 `checkFile` 返回的 `uploadedList` 过滤已上传切片，实现断点续传
5. **响应式更新**：使用 `reactive` 确保 Vue3 能正确追踪状态变化

