# 前端性能监控原理详解与面试问答

本文档详细分析 `PerformanceOptimization` 组件实现的前端性能监控系统，包括技术详解、技术选型原因以及面试常见问题与解答。

## 目录

1. [概述](#概述)
2. [核心技术详解](#核心技术详解)
3. [监控指标详解](#监控指标详解)
4. [技术选型原因](#技术选型原因)
5. [实现原理深度解析](#实现原理深度解析)
6. [批量上报机制](#批量上报机制)
7. [面试问题与解答](#面试问题与解答)
8. [最佳实践建议](#最佳实践建议)

---

## 概述

前端性能监控是前端工程化的重要组成部分，通过收集和分析用户真实环境下的性能数据，帮助开发者：

- **发现问题**：及时发现性能瓶颈和问题
- **优化方向**：提供数据支持，指导性能优化
- **用户体验**：提升用户体验，减少用户流失
- **业务价值**：通过性能优化提升业务指标

本实现基于 **Web Vitals** 标准，监控了 8 个核心性能指标，并提供了完整的批量上报机制。

---

## 核心技术详解

### 1. Web Vitals 库

#### 1.1 技术选型

**使用库**：`web-vitals`

```typescript
import { onCLS, onFCP, onINP, onLCP, onTTFB } from 'web-vitals';
```

**为什么选择 web-vitals？**

- ✅ **Google 官方标准**：基于 Google 提出的 Web Vitals 标准
- ✅ **准确性高**：使用 PerformanceObserver API，数据准确可靠
- ✅ **自动计算**：自动计算核心性能指标，无需手动实现
- ✅ **跨浏览器**：兼容性好，支持现代浏览器
- ✅ **轻量级**：体积小，性能影响小

#### 1.2 核心指标

Web Vitals 定义了三个核心指标（Core Web Vitals）：

1. **LCP (Largest Contentful Paint)**：最大内容绘制
2. **FID (First Input Delay)** → **INP (Interaction to Next Paint)**：首次输入延迟 → 交互到下次绘制
3. **CLS (Cumulative Layout Shift)**：累积布局偏移

### 2. PerformanceObserver API

#### 2.1 技术选型

**使用 API**：`PerformanceObserver`

```typescript
const observer = new PerformanceObserver(list => {
  const entries = list.getEntries();
  // 处理性能条目
});
observer.observe({ entryTypes: ['longtask'] });
```

**为什么选择 PerformanceObserver？**

- ✅ **异步观察**：异步观察性能指标，不阻塞主线程
- ✅ **精确数据**：提供精确的性能数据
- ✅ **自动收集**：自动收集性能条目，无需手动计算
- ✅ **支持多种类型**：支持 longtask、navigation、resource 等多种类型

#### 2.2 支持的 Entry Types

- `longtask`：长任务监控
- `navigation`：页面导航性能
- `resource`：资源加载性能
- `paint`：绘制性能
- `measure`：自定义性能测量

### 3. requestAnimationFrame API

#### 3.1 技术选型

**使用 API**：`requestAnimationFrame`

```typescript
const measureFrame = (currentTime: number) => {
  fpsMonitor.frameCount++;
  
  if (currentTime - fpsMonitor.lastTime >= sampleInterval) {
    const fps = (fpsMonitor.frameCount * 1000) / (currentTime - sampleStartTime);
    fpsMonitor.samples.push(fps);
    // ...
  }
  
  requestAnimationFrame(measureFrame);
};
```

**为什么选择 requestAnimationFrame？**

- ✅ **与浏览器刷新率同步**：与浏览器刷新率同步，精确计算 FPS
- ✅ **自动暂停**：页面不可见时自动暂停，节省资源
- ✅ **高精度**：提供高精度的时间戳
- ✅ **性能友好**：浏览器优化，性能影响小

### 4. Performance API

#### 4.1 技术选型

**使用 API**：`performance.memory`

```typescript
const memory = (performance as any).memory;
const memoryData = {
  usedJSHeapSize: memory.usedJSHeapSize,
  totalJSHeapSize: memory.totalJSHeapSize,
  jsHeapSizeLimit: memory.jsHeapSizeLimit,
  memoryUsage: (memory.usedJSHeapSize / memory.jsHeapSizeLimit) * 100
};
```

**为什么选择 performance.memory？**

- ✅ **实时数据**：提供实时的内存使用数据
- ✅ **详细信息**：提供堆内存使用、限制等详细信息
- ✅ **易于监控**：可以定期采样，监控内存变化趋势

**注意**：`performance.memory` 只在 Chrome 等浏览器中可用。

---

## 监控指标详解

### 1. LCP (Largest Contentful Paint) - 最大内容绘制

#### 1.1 定义

**LCP** 测量页面加载过程中，最大内容元素（如图片、视频、文本块）渲染到屏幕的时间。

#### 1.2 实现原理

```typescript
onLCP((metric) => {
  const data: WebVitalsData = {
    name: 'LCP',
    value: metric.value,
    rating: metric.rating,
    delta: metric.delta,
    id: metric.id,
    navigationType: metric.navigationType
  };
  handleWebVitalsData(data, config);
});
```

#### 1.3 评级标准

| 评级 | LCP 值 | 说明 |
|------|--------|------|
| **good** | ≤ 2.5s | 良好 |
| **needs-improvement** | 2.5s - 4.0s | 需要改进 |
| **poor** | > 4.0s | 较差 |

#### 1.4 优化建议

- 优化服务器响应时间
- 使用 CDN 加速资源加载
- 优化图片大小和格式
- 预加载关键资源

### 2. FCP (First Contentful Paint) - 首次内容绘制

#### 2.1 定义

**FCP** 测量页面首次渲染任何内容（文本、图片、SVG 等）的时间。

#### 2.2 实现原理

```typescript
onFCP((metric) => {
  const data: WebVitalsData = {
    name: 'FCP',
    value: metric.value,
    rating: metric.rating,
    delta: metric.delta,
    id: metric.id,
    navigationType: metric.navigationType
  };
  handleWebVitalsData(data, config);
});
```

#### 2.3 评级标准

| 评级 | FCP 值 | 说明 |
|------|--------|------|
| **good** | ≤ 1.8s | 良好 |
| **needs-improvement** | 1.8s - 3.0s | 需要改进 |
| **poor** | > 3.0s | 较差 |

### 3. CLS (Cumulative Layout Shift) - 累积布局偏移

#### 3.1 定义

**CLS** 测量页面加载过程中，元素位置发生意外移动的程度。

#### 3.2 实现原理

```typescript
onCLS((metric) => {
  const data: WebVitalsData = {
    name: 'CLS',
    value: metric.value,
    rating: metric.rating,
    delta: metric.delta,
    id: metric.id,
    navigationType: metric.navigationType
  };
  handleWebVitalsData(data, config);
});
```

#### 3.3 评级标准

| 评级 | CLS 值 | 说明 |
|------|--------|------|
| **good** | ≤ 0.1 | 良好 |
| **needs-improvement** | 0.1 - 0.25 | 需要改进 |
| **poor** | > 0.25 | 较差 |

#### 3.4 优化建议

- 为图片和视频设置尺寸属性
- 避免在现有内容上方插入内容
- 使用 CSS transform 动画，而不是改变布局属性

### 4. TTFB (Time to First Byte) - 首字节时间

#### 4.1 定义

**TTFB** 测量从请求页面到收到服务器响应的第一个字节的时间。

#### 4.2 实现原理

```typescript
onTTFB((metric) => {
  const data: WebVitalsData = {
    name: 'TTFB',
    value: metric.value,
    rating: metric.rating,
    delta: metric.delta,
    id: metric.id,
    navigationType: metric.navigationType
  };
  handleWebVitalsData(data, config);
});
```

#### 4.3 评级标准

| 评级 | TTFB 值 | 说明 |
|------|---------|------|
| **good** | ≤ 800ms | 良好 |
| **needs-improvement** | 800ms - 1.8s | 需要改进 |
| **poor** | > 1.8s | 较差 |

### 5. INP (Interaction to Next Paint) - 交互到下次绘制

#### 5.1 定义

**INP** 测量用户交互（点击、键盘输入等）到页面响应的延迟时间。

#### 5.2 实现原理

```typescript
onINP((metric) => {
  const data: WebVitalsData = {
    name: 'INP',
    value: metric.value,
    rating: metric.rating,
    delta: metric.delta,
    id: metric.id,
    navigationType: metric.navigationType
  };
  handleWebVitalsData(data, config);
});
```

#### 5.3 评级标准

| 评级 | INP 值 | 说明 |
|------|--------|------|
| **good** | ≤ 200ms | 良好 |
| **needs-improvement** | 200ms - 500ms | 需要改进 |
| **poor** | > 500ms | 较差 |

**注意**：INP 是 FID 的替代指标，更全面地反映交互性能。

### 6. FPS (Frames Per Second) - 帧率

#### 6.1 定义

**FPS** 测量页面渲染的帧率，反映页面流畅度。

#### 6.2 实现原理

```typescript
function startFPSMonitoring(config: WebVitalsConfig) {
  const fpsConfig = { ...DEFAULT_FPS_CONFIG, ...config.fpsConfig };
  
  fpsMonitor = {
    startTime: performance.now(),
    frameCount: 0,
    lastTime: performance.now(),
    samples: [],
    isRunning: true,
    animationId: null,
    sampleStartTime: performance.now()
  };
  
  const measureFrame = (currentTime: number) => {
    fpsMonitor.frameCount++;
    
    // 每 100ms 采样一次
    if (currentTime - fpsMonitor.lastTime >= fpsConfig.sampleInterval) {
      const fps = (fpsMonitor.frameCount * 1000) / 
                  (currentTime - fpsMonitor.sampleStartTime);
      fpsMonitor.samples.push(fps);
      
      // 重置计数器
      fpsMonitor.lastTime = currentTime;
      fpsMonitor.frameCount = 0;
      fpsMonitor.sampleStartTime = currentTime;
    }
    
    // 检查是否达到监控持续时间
    if (currentTime - fpsMonitor.startTime >= fpsConfig.duration) {
      stopFPSMonitoring(config);
      return;
    }
    
    fpsMonitor.animationId = requestAnimationFrame(measureFrame);
  };
  
  fpsMonitor.animationId = requestAnimationFrame(measureFrame);
}
```

#### 6.3 计算原理

```
FPS = (帧数 × 1000) / 采样时间(ms)
```

**示例**：
- 采样时间：100ms
- 帧数：6 帧
- FPS = (6 × 1000) / 100 = 60fps

#### 6.4 评级标准

| 评级 | FPS 值 | 说明 |
|------|--------|------|
| **good** | ≥ 60fps | 流畅 |
| **needs-improvement** | 30-60fps | 可接受 |
| **poor** | < 30fps | 卡顿 |

### 7. LongTask - 长任务

#### 7.1 定义

**LongTask** 测量执行时间超过 50ms 的任务，这些任务会阻塞主线程，影响页面响应。

#### 7.2 实现原理

```typescript
function startLongTaskMonitoring(config: WebVitalsConfig) {
  const observer = new PerformanceObserver(list => {
    const entries = list.getEntries();
    
    for (const entry of entries) {
      if (entry.entryType === 'longtask' && entry.duration >= threshold) {
        const longTaskData: LongTaskData = {
          name: entry.name || 'unknown',
          duration: entry.duration,
          startTime: entry.startTime,
          attribution: (entry as any).attribution
        };
        
        // 上报长任务数据
        handleWebVitalsData(data, config);
      }
    }
  });
  
  observer.observe({ entryTypes: ['longtask'] });
}
```

#### 7.3 评级标准

| 评级 | 长任务数量 | 说明 |
|------|-----------|------|
| **good** | ≤ 5 个 | 良好 |
| **needs-improvement** | 5-15 个 | 需要改进 |
| **poor** | > 15 个 | 较差 |

#### 7.4 优化建议

- 使用 Web Worker 处理耗时任务
- 将大任务拆分成小任务
- 使用 `requestIdleCallback` 在空闲时执行任务
- 优化 JavaScript 代码，减少执行时间

### 8. Memory - 内存监控

#### 8.1 定义

**Memory** 监控 JavaScript 堆内存使用情况，检测内存泄漏。

#### 8.2 实现原理

```typescript
function startMemoryLeakMonitoring(config: WebVitalsConfig) {
  const monitorMemory = () => {
    const memory = (performance as any).memory;
    
    const memoryData: MemoryLeakData = {
      name: 'MemoryLeak',
      usedJSHeapSize: memory.usedJSHeapSize,
      totalJSHeapSize: memory.totalJSHeapSize,
      jsHeapSizeLimit: memory.jsHeapSizeLimit,
      memoryUsage: (memory.usedJSHeapSize / memory.jsHeapSizeLimit) * 100,
      timestamp: Date.now(),
      leakScore: calculateLeakScore(memoryData),
      trend: calculateTrend(memoryData)
    };
    
    // 检测内存泄漏
    if (memoryData.leakScore > 50 && memoryData.trend === 'increasing') {
      console.error('🚨 检测到潜在内存泄漏!');
      handleWebVitalsData(webVitalsData, config);
    }
  };
  
  // 每 5 秒监控一次
  setInterval(monitorMemory, 5000);
}
```

#### 8.3 泄漏评分计算

```typescript
// 泄漏评分 = 增长率评分(0-70分) + 使用率评分(0-30分)
const growthScore = Math.min(70, (growthRate / threshold) * 70);
const usageScore = Math.min(30, (memoryUsage / 100) * 30);
const leakScore = growthScore + usageScore;
```

#### 8.4 评级标准

| 评级 | 内存使用率 | 说明 |
|------|-----------|------|
| **good** | ≤ 50% | 良好 |
| **needs-improvement** | 50% - 80% | 需要改进 |
| **poor** | > 80% | 较差 |

---

## 技术选型原因

### 1. 为什么选择 web-vitals 库？

#### 1.1 官方标准

- ✅ **Google 官方推荐**：Web Vitals 是 Google 提出的性能标准
- ✅ **行业认可**：被广泛采用，成为行业标准
- ✅ **持续更新**：Google 持续维护和更新

#### 1.2 技术优势

- ✅ **准确性高**：基于 PerformanceObserver API，数据准确
- ✅ **自动计算**：自动计算指标，无需手动实现复杂逻辑
- ✅ **跨浏览器**：兼容性好，支持现代浏览器
- ✅ **轻量级**：体积小（~5KB），性能影响小

#### 1.3 对比其他方案

| 方案 | 优势 | 劣势 |
|------|------|------|
| **web-vitals** | 官方标准、准确、易用 | 需要额外实现 FPS、LongTask |
| **自定义实现** | 完全可控 | 实现复杂、容易出错 |
| **第三方 SDK** | 功能完整 | 体积大、可能有隐私问题 |

### 2. 为什么使用 PerformanceObserver？

#### 2.1 技术优势

- ✅ **异步观察**：不阻塞主线程
- ✅ **精确数据**：提供精确的性能数据
- ✅ **自动收集**：自动收集性能条目
- ✅ **支持多种类型**：支持多种性能条目类型

#### 2.2 对比其他方案

| 方案 | 优势 | 劣势 |
|------|------|------|
| **PerformanceObserver** | 异步、精确、自动 | 需要浏览器支持 |
| **performance.timing** | 兼容性好 | 已废弃，数据不准确 |
| **手动计算** | 完全可控 | 实现复杂、容易出错 |

### 3. 为什么使用 requestAnimationFrame 监控 FPS？

#### 3.1 技术优势

- ✅ **与刷新率同步**：与浏览器刷新率同步，精确计算 FPS
- ✅ **自动暂停**：页面不可见时自动暂停
- ✅ **高精度**：提供高精度时间戳
- ✅ **性能友好**：浏览器优化，性能影响小

#### 3.2 对比其他方案

| 方案 | 优势 | 劣势 |
|------|------|------|
| **requestAnimationFrame** | 精确、同步、性能好 | 需要手动计算 |
| **setInterval** | 简单 | 不精确、可能不同步 |
| **Chrome DevTools** | 专业工具 | 仅开发环境可用 |

### 4. 为什么使用批量上报？

#### 4.1 技术优势

- ✅ **减少请求数**：批量上报减少 HTTP 请求数
- ✅ **提高效率**：减少网络开销，提高上报效率
- ✅ **降低服务器压力**：减少服务器处理请求的压力
- ✅ **可靠性高**：使用 sendBeacon 确保页面卸载时数据不丢失

#### 4.2 对比其他方案

| 方案 | 优势 | 劣势 |
|------|------|------|
| **批量上报** | 高效、可靠 | 实现复杂 |
| **单个上报** | 简单 | 请求多、效率低 |
| **本地存储** | 离线支持 | 需要额外处理 |

---

## 实现原理深度解析

### 1. Web Vitals 监控流程

```
页面加载
    ↓
web-vitals 库自动监听 PerformanceObserver
    ↓
检测到性能指标变化
    ↓
计算指标值（LCP、FCP、CLS、TTFB、INP）
    ↓
触发回调函数
    ↓
构建 WebVitalsData 对象
    ↓
评级（good/needs-improvement/poor）
    ↓
handleWebVitalsData()
    ↓
批量上报队列 / 单个上报
```

### 2. FPS 监控流程

```
startFPSMonitoring()
    ↓
初始化 fpsMonitor
    ↓
requestAnimationFrame(measureFrame)
    ↓
每帧执行 measureFrame
    ↓
frameCount++
    ↓
每 100ms 采样一次
    ↓
计算 FPS = (frameCount × 1000) / 采样时间
    ↓
保存到 samples 数组
    ↓
达到监控持续时间？
    ↓
计算平均 FPS
    ↓
上报数据
```

### 3. 长任务监控流程

```
startLongTaskMonitoring()
    ↓
创建 PerformanceObserver
    ↓
监听 'longtask' 类型
    ↓
检测到长任务（duration ≥ 50ms）
    ↓
提取任务信息（duration、startTime、attribution）
    ↓
构建 LongTaskData 对象
    ↓
实时上报 / 汇总上报
```

### 4. 内存泄漏监控流程

```
startMemoryLeakMonitoring()
    ↓
设置定时器（每 5 秒）
    ↓
读取 performance.memory
    ↓
计算内存使用率
    ↓
计算内存增长率
    ↓
计算泄漏评分（0-100）
    ↓
检测趋势（stable/increasing/decreasing）
    ↓
泄漏评分 > 50 且趋势为 increasing？
    ↓
上报内存泄漏警告
```

---

## 批量上报机制

### 1. 批量上报原理

#### 1.1 队列管理

```typescript
interface BatchReportQueue {
  queue: Array<WebVitalsData & { timestamp: number; url: string; userAgent: string }>;
  timer: number | null;
  config: {
    batchSize: number;        // 批量大小（默认 10）
    batchInterval: number;    // 批量间隔（默认 120 秒）
    batchReportUrl: string;    // 上报 URL
  };
  isEnabled: boolean;
}
```

#### 1.2 添加数据到队列

```typescript
function addToBatchQueue(data: WebVitalsData, config: WebVitalsConfig) {
  const queueData = {
    ...data,
    timestamp: Date.now(),
    url: window.location.href,
    userAgent: navigator.userAgent,
    environment: import.meta.env.MODE
  };
  
  batchReportQueue.queue.push(queueData);
  
  // 检查是否达到批量大小
  if (batchReportQueue.queue.length >= batchReportQueue.config.batchSize) {
    flushBatchReport(); // 立即上报
    return;
  }
  
  // 设置定时器，超时后自动上报
  if (batchReportQueue.timer === null) {
    batchReportQueue.timer = window.setTimeout(() => {
      if (batchReportQueue.queue.length > 0) {
        flushBatchReport();
      }
    }, batchReportQueue.config.batchInterval);
  }
}
```

#### 1.3 执行批量上报

```typescript
async function flushBatchReport() {
  if (!batchReportQueue || batchReportQueue.queue.length === 0) return;
  
  const dataToReport = [...batchReportQueue.queue];
  
  // 清空队列
  batchReportQueue.queue = [];
  
  // 清除定时器
  if (batchReportQueue.timer !== null) {
    clearTimeout(batchReportQueue.timer);
    batchReportQueue.timer = null;
  }
  
  // 上报数据
  await fetch(batchReportQueue.config.batchReportUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      batch: dataToReport,
      batchSize: dataToReport.length,
      batchTimestamp: Date.now()
    })
  });
}
```

### 2. 页面卸载处理

#### 2.1 sendBeacon API

```typescript
window.addEventListener('beforeunload', () => {
  if (batchReportQueue && batchReportQueue.queue.length > 0) {
    const data = JSON.stringify({
      batch: batchReportQueue.queue,
      batchSize: batchReportQueue.queue.length,
      batchTimestamp: Date.now()
    });
    
    // 使用 sendBeacon 确保数据不丢失
    navigator.sendBeacon(batchReportUrl, data);
  }
});
```

**为什么使用 sendBeacon？**

- ✅ **可靠性高**：即使页面卸载也能发送数据
- ✅ **不阻塞**：异步发送，不阻塞页面卸载
- ✅ **自动重试**：浏览器自动处理网络问题

#### 2.2 visibilitychange 事件

```typescript
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'hidden' && 
      batchReportQueue && 
      batchReportQueue.queue.length > 0) {
    flushBatchReport(); // 页面隐藏时上报
  }
});
```

### 3. 批量上报优势

| 优势 | 说明 |
|------|------|
| **减少请求数** | 10 条数据合并为 1 个请求，减少 90% 请求数 |
| **提高效率** | 减少网络开销，提高上报效率 |
| **降低服务器压力** | 减少服务器处理请求的压力 |
| **可靠性高** | 使用 sendBeacon 确保数据不丢失 |

---

## 面试问题与解答

### Q1: 什么是 Web Vitals？为什么要监控这些指标？

**答案**：

**Web Vitals 定义**：

Web Vitals 是 Google 提出的性能标准，定义了三个核心指标（Core Web Vitals）：

1. **LCP (Largest Contentful Paint)**：最大内容绘制
2. **INP (Interaction to Next Paint)**：交互到下次绘制（替代 FID）
3. **CLS (Cumulative Layout Shift)**：累积布局偏移

**为什么要监控？**

1. **用户体验**：这些指标直接反映用户体验
2. **SEO 排名**：Google 将 Core Web Vitals 作为搜索排名因素
3. **业务价值**：性能优化可以提升转化率、降低跳出率
4. **问题发现**：及时发现性能问题，指导优化方向

**实现代码**：

```typescript
import { onLCP, onINP, onCLS } from 'web-vitals';

onLCP((metric) => {
  console.log('LCP:', metric.value, metric.rating);
});

onINP((metric) => {
  console.log('INP:', metric.value, metric.rating);
});

onCLS((metric) => {
  console.log('CLS:', metric.value, metric.rating);
});
```

### Q2: 如何监控 FPS？实现原理是什么？

**答案**：

**FPS 监控原理**：

使用 `requestAnimationFrame` API，在每一帧执行时计数，然后计算帧率。

**实现步骤**：

1. **初始化监控器**：
   ```typescript
   fpsMonitor = {
     startTime: performance.now(),
     frameCount: 0,
     lastTime: performance.now(),
     samples: [],
     isRunning: true
   };
   ```

2. **每帧计数**：
   ```typescript
   const measureFrame = (currentTime: number) => {
     fpsMonitor.frameCount++;
     
     // 每 100ms 采样一次
     if (currentTime - fpsMonitor.lastTime >= 100) {
       const fps = (fpsMonitor.frameCount * 1000) / 
                   (currentTime - fpsMonitor.sampleStartTime);
       fpsMonitor.samples.push(fps);
       
       // 重置计数器
       fpsMonitor.frameCount = 0;
       fpsMonitor.sampleStartTime = currentTime;
     }
     
     requestAnimationFrame(measureFrame);
   };
   ```

3. **计算平均 FPS**：
   ```typescript
   const averageFPS = fpsMonitor.samples.reduce((sum, fps) => sum + fps, 0) / 
                      fpsMonitor.samples.length;
   ```

**为什么使用 requestAnimationFrame？**

- ✅ **与刷新率同步**：与浏览器刷新率同步，精确计算 FPS
- ✅ **自动暂停**：页面不可见时自动暂停，节省资源
- ✅ **高精度**：提供高精度时间戳

### Q3: 如何检测长任务？长任务对性能有什么影响？

**答案**：

**长任务检测**：

使用 `PerformanceObserver` API 监听 `longtask` 类型：

```typescript
const observer = new PerformanceObserver(list => {
  const entries = list.getEntries();
  
  for (const entry of entries) {
    if (entry.entryType === 'longtask' && entry.duration >= 50) {
      console.log('检测到长任务:', entry.duration, 'ms');
    }
  }
});

observer.observe({ entryTypes: ['longtask'] });
```

**长任务的影响**：

1. **阻塞主线程**：长任务会阻塞主线程，导致页面卡顿
2. **影响交互**：用户交互无法及时响应
3. **影响渲染**：导致帧率下降，页面不流畅

**优化建议**：

- ✅ 使用 Web Worker 处理耗时任务
- ✅ 将大任务拆分成小任务
- ✅ 使用 `requestIdleCallback` 在空闲时执行任务
- ✅ 优化 JavaScript 代码，减少执行时间

### Q4: 如何检测内存泄漏？检测原理是什么？

**答案**：

**内存泄漏检测原理**：

1. **定期采样**：每 5 秒读取 `performance.memory`
2. **计算使用率**：`内存使用率 = usedJSHeapSize / jsHeapSizeLimit × 100%`
3. **计算增长率**：`增长率 = (当前内存 - 基准内存) / 时间`
4. **计算泄漏评分**：`泄漏评分 = 增长率评分(0-70) + 使用率评分(0-30)`
5. **检测趋势**：分析最近几个样本，判断趋势（stable/increasing/decreasing）

**实现代码**：

```typescript
function detectMemoryLeak() {
  const memory = (performance as any).memory;
  
  const memoryData = {
    usedJSHeapSize: memory.usedJSHeapSize,
    totalJSHeapSize: memory.totalJSHeapSize,
    jsHeapSizeLimit: memory.jsHeapSizeLimit,
    memoryUsage: (memory.usedJSHeapSize / memory.jsHeapSizeLimit) * 100
  };
  
  // 计算增长率
  const growthRate = (memoryData.usedJSHeapSize - baselineMemory) / elapsedTime;
  
  // 计算泄漏评分
  const growthScore = Math.min(70, (growthRate / threshold) * 70);
  const usageScore = Math.min(30, (memoryData.memoryUsage / 100) * 30);
  const leakScore = growthScore + usageScore;
  
  // 检测趋势
  const trend = calculateTrend(samples);
  
  // 判断是否泄漏
  if (leakScore > 50 && trend === 'increasing') {
    console.error('🚨 检测到潜在内存泄漏!');
  }
}
```

**常见内存泄漏原因**：

- 未清理的事件监听器
- 未清理的定时器
- 闭包引用
- DOM 引用未释放
- 全局变量累积

### Q5: 为什么要使用批量上报？如何实现？

**答案**：

**为什么使用批量上报？**

1. **减少请求数**：10 条数据合并为 1 个请求，减少 90% 请求数
2. **提高效率**：减少网络开销，提高上报效率
3. **降低服务器压力**：减少服务器处理请求的压力
4. **节省带宽**：减少 HTTP 请求头开销

**实现原理**：

```typescript
// 1. 初始化队列
const batchReportQueue = {
  queue: [],
  timer: null,
  config: {
    batchSize: 10,        // 达到 10 条立即上报
    batchInterval: 120000 // 120 秒超时上报
  }
};

// 2. 添加数据到队列
function addToBatchQueue(data) {
  batchReportQueue.queue.push(data);
  
  // 达到批量大小，立即上报
  if (batchReportQueue.queue.length >= batchReportQueue.config.batchSize) {
    flushBatchReport();
    return;
  }
  
  // 设置定时器，超时后自动上报
  if (batchReportQueue.timer === null) {
    batchReportQueue.timer = setTimeout(() => {
      flushBatchReport();
    }, batchReportQueue.config.batchInterval);
  }
}

// 3. 执行批量上报
async function flushBatchReport() {
  const dataToReport = [...batchReportQueue.queue];
  batchReportQueue.queue = [];
  
  await fetch(reportUrl, {
    method: 'POST',
    body: JSON.stringify({
      batch: dataToReport,
      batchSize: dataToReport.length,
      batchTimestamp: Date.now()
    })
  });
}
```

### Q6: 页面卸载时如何确保数据不丢失？

**答案**：

**使用 sendBeacon API**：

```typescript
window.addEventListener('beforeunload', () => {
  if (batchReportQueue.queue.length > 0) {
    const data = JSON.stringify({
      batch: batchReportQueue.queue,
      batchSize: batchReportQueue.queue.length,
      batchTimestamp: Date.now()
    });
    
    // 使用 sendBeacon 确保数据不丢失
    navigator.sendBeacon(reportUrl, data);
  }
});
```

**sendBeacon 的优势**：

- ✅ **可靠性高**：即使页面卸载也能发送数据
- ✅ **不阻塞**：异步发送，不阻塞页面卸载
- ✅ **自动重试**：浏览器自动处理网络问题
- ✅ **优先级高**：浏览器优先处理 sendBeacon 请求

**其他方案**：

- **visibilitychange 事件**：页面隐藏时上报
- **同步 XMLHttpRequest**：阻塞页面卸载（不推荐）
- **localStorage**：存储到本地，下次加载时上报

### Q7: 如何优化性能监控对页面性能的影响？

**答案**：

**优化措施**：

1. **异步处理**：使用 PerformanceObserver 异步观察，不阻塞主线程
2. **批量上报**：减少请求数，降低网络开销
3. **采样率控制**：可以设置采样率，只监控部分用户
4. **延迟上报**：使用 requestIdleCallback 在空闲时上报
5. **按需监控**：只在需要时启动监控（如 FPS 监控）

**实现代码**：

```typescript
// 1. 使用 requestIdleCallback 延迟上报
function reportData(data) {
  if ('requestIdleCallback' in window) {
    requestIdleCallback(() => {
      fetch(reportUrl, { method: 'POST', body: JSON.stringify(data) });
    });
  } else {
    setTimeout(() => {
      fetch(reportUrl, { method: 'POST', body: JSON.stringify(data) });
    }, 0);
  }
}

// 2. 采样率控制
function shouldReport() {
  const sampleRate = 0.1; // 10% 采样率
  return Math.random() < sampleRate;
}

// 3. 按需监控
function startFPSMonitoring(duration = 10000) {
  // 只在需要时启动，监控指定时间后自动停止
}
```

### Q8: PerformanceObserver 和 performance.timing 有什么区别？

**答案**：

**PerformanceObserver**：

- ✅ **现代 API**：W3C 标准，推荐使用
- ✅ **异步观察**：不阻塞主线程
- ✅ **精确数据**：提供精确的性能数据
- ✅ **支持多种类型**：支持 longtask、navigation、resource 等
- ✅ **实时监控**：可以实时监控性能变化

**performance.timing**：

- ❌ **已废弃**：已被 PerformanceObserver 替代
- ❌ **同步计算**：需要手动计算，可能阻塞主线程
- ❌ **数据不准确**：某些数据可能不准确
- ❌ **功能有限**：不支持长任务等新特性

**对比示例**：

```typescript
// ❌ 旧方式（已废弃）
const timing = performance.timing;
const loadTime = timing.loadEventEnd - timing.navigationStart;

// ✅ 新方式（推荐）
const observer = new PerformanceObserver(list => {
  const entries = list.getEntries();
  for (const entry of entries) {
    if (entry.entryType === 'navigation') {
      console.log('Load time:', entry.loadEventEnd - entry.fetchStart);
    }
  }
});
observer.observe({ entryTypes: ['navigation'] });
```

### Q9: 如何计算 CLS（累积布局偏移）？

**答案**：

**CLS 计算原理**：

CLS 测量页面加载过程中，元素位置发生意外移动的程度。

**计算公式**：

```
CLS = Σ (影响分数 × 距离分数)
```

- **影响分数**：不稳定元素影响视口的比例（0-1）
- **距离分数**：元素移动的距离占视口的比例（0-1）

**实现代码**：

```typescript
// web-vitals 库自动计算
import { onCLS } from 'web-vitals';

onCLS((metric) => {
  console.log('CLS:', metric.value); // 累积布局偏移分数
  console.log('Rating:', metric.rating); // good/needs-improvement/poor
});
```

**优化建议**：

- ✅ 为图片和视频设置尺寸属性（width、height）
- ✅ 避免在现有内容上方插入内容
- ✅ 使用 CSS transform 动画，而不是改变布局属性
- ✅ 使用 font-display: swap 避免字体加载导致的布局偏移

### Q10: 如何区分不同类型的性能问题？

**答案**：

**性能问题分类**：

1. **加载性能问题**：
   - LCP 高 → 优化最大内容元素加载
   - FCP 高 → 优化首次渲染
   - TTFB 高 → 优化服务器响应时间

2. **交互性能问题**：
   - INP 高 → 优化 JavaScript 执行时间
   - FPS 低 → 优化渲染性能
   - LongTask 多 → 优化长任务

3. **视觉稳定性问题**：
   - CLS 高 → 优化布局偏移

4. **内存问题**：
   - Memory 使用率高 → 检测内存泄漏
   - MemoryGrowthRate 高 → 优化内存使用

**诊断流程**：

```
性能问题
    ↓
查看 Web Vitals 指标
    ↓
LCP 高？ → 优化加载性能
INP 高？ → 优化交互性能
CLS 高？ → 优化布局稳定性
FPS 低？ → 优化渲染性能
LongTask 多？ → 优化长任务
Memory 高？ → 检测内存泄漏
```

---

## 最佳实践建议

### 1. 监控指标选择

**核心指标（必须监控）**：

- ✅ LCP：最大内容绘制
- ✅ INP：交互到下次绘制
- ✅ CLS：累积布局偏移

**扩展指标（建议监控）**：

- ✅ FCP：首次内容绘制
- ✅ TTFB：首字节时间
- ✅ FPS：帧率
- ✅ LongTask：长任务
- ✅ Memory：内存使用

### 2. 上报策略

**批量上报配置**：

```typescript
batchConfig: {
  enabled: true,
  batchSize: 10,        // 达到 10 条立即上报
  batchInterval: 120000 // 120 秒超时上报
}
```

**采样率配置**：

```typescript
// 生产环境可以设置采样率，减少数据量
sampleRate: process.env.NODE_ENV === 'production' ? 0.1 : 1.0
```

### 3. 性能优化

**减少监控开销**：

- ✅ 使用异步 API（PerformanceObserver）
- ✅ 批量上报，减少请求数
- ✅ 按需监控（如 FPS 只在需要时监控）
- ✅ 使用 requestIdleCallback 延迟上报

### 4. 数据存储

**建议存储字段**：

- 性能指标值（value）
- 评级（rating）
- 时间戳（timestamp）
- URL（url）
- 用户代理（userAgent）
- 环境信息（environment）

### 5. 告警机制

**建议设置告警阈值**：

- LCP > 4.0s → 告警
- INP > 500ms → 告警
- CLS > 0.25 → 告警
- FPS < 30fps → 告警
- Memory > 80% → 告警

---

## 总结

前端性能监控是前端工程化的重要组成部分，通过监控核心性能指标，可以帮助开发者：

### 核心价值

1. ✅ **发现问题**：及时发现性能瓶颈
2. ✅ **优化方向**：提供数据支持，指导优化
3. ✅ **用户体验**：提升用户体验
4. ✅ **业务价值**：通过性能优化提升业务指标

### 技术要点

1. ✅ **Web Vitals 标准**：使用 Google 官方标准
2. ✅ **PerformanceObserver API**：异步观察性能指标
3. ✅ **批量上报机制**：提高上报效率
4. ✅ **sendBeacon API**：确保数据不丢失

### 监控指标

- **核心指标**：LCP、INP、CLS
- **扩展指标**：FCP、TTFB、FPS、LongTask、Memory

通过合理使用这些技术和指标，可以构建一个完整、高效的前端性能监控系统。

