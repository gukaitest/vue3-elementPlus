# Vue3-ElementPlus 主题样式切换原理详解

## 目录

1. [概述](#概述)
2. [核心架构](#核心架构)
3. [主题存储管理](#主题存储管理)
4. [暗色模式切换](#暗色模式切换)
5. [主题颜色系统](#主题颜色系统)
6. [CSS变量注入机制](#css变量注入机制)
7. [UI组件主题适配](#ui组件主题适配)
8. [主题设置持久化](#主题设置持久化)
9. [用户界面组件](#用户界面组件)
10. [完整流程示例](#完整流程示例)

---

## 概述

该项目实现了一套完整的主题样式切换系统，支持：

- **三种主题方案**：亮色（light）、暗色（dark）、自动（auto）
- **动态主题颜色**：可自定义主色、信息色、成功色、警告色、错误色
- **布局模式切换**：垂直、水平、混合等多种布局
- **辅助功能**：灰度模式、色弱模式
- **实时预览**：所有更改即时生效，无需刷新页面

---

## 核心架构

### 文件结构

```
src/
├── store/modules/theme/
│   ├── index.ts          # 主题 Store 主文件
│   └── shared.ts         # 主题工具函数
├── theme/
│   ├── settings.ts       # 默认主题配置
│   └── vars.ts          # CSS 变量定义
├── layouts/modules/theme-drawer/
│   ├── index.vue         # 主题抽屉主组件
│   └── modules/
│       ├── dark-mode.vue      # 暗色模式切换
│       ├── theme-color.vue    # 主题颜色选择
│       ├── layout-mode.vue    # 布局模式选择
│       └── page-fun.vue       # 页面功能配置
└── constants/app.ts      # 主题相关常量
```

### 技术栈

- **状态管理**：Pinia (Vue 3)
- **响应式系统**：Vue 3 Composition API
- **工具库**：@vueuse/core (系统主题检测)
- **颜色处理**：@sa/color (颜色调色板生成)

---

## 主题存储管理

### Theme Store 结构

主题状态通过 Pinia Store 进行集中管理，位于 `src/store/modules/theme/index.ts`：

```typescript
export const useThemeStore = defineStore(SetupStoreId.Theme, () => {
  // 1. 系统主题检测
  const osTheme = usePreferredColorScheme(); // 'light' | 'dark'

  // 2. 主题设置（响应式引用）
  const settings: Ref<App.Theme.ThemeSetting> = ref(initThemeSettings());

  // 3. 计算属性
  const darkMode = computed(() => {
    if (settings.value.themeScheme === "auto") {
      return osTheme.value === "dark"; // 跟随系统
    }
    return settings.value.themeScheme === "dark";
  });

  const themeColors = computed(() => {
    const { themeColor, otherColor, isInfoFollowPrimary } = settings.value;
    return {
      primary: themeColor,
      ...otherColor,
      info: isInfoFollowPrimary ? themeColor : otherColor.info,
    };
  });

  // 4. 监听器（自动应用主题）
  watch(
    darkMode,
    (val) => {
      toggleCssDarkMode(val);
      localStg.set("darkMode", val);
    },
    { immediate: true },
  );

  watch(
    themeColors,
    (val) => {
      setupThemeVarsToGlobal();
      localStg.set("themeColor", val.primary);
    },
    { immediate: true },
  );
});
```

### 主题设置初始化

`initThemeSettings()` 函数负责初始化主题配置：

```typescript
export function initThemeSettings() {
  const isProd = import.meta.env.PROD;

  // 开发模式：直接使用默认配置
  if (!isProd) return themeSettings;

  // 生产模式：从 localStorage 读取缓存
  const localSettings = localStg.get("themeSettings");
  let settings = defu(localSettings, themeSettings);

  // 版本更新时覆盖特定设置
  const isOverride = localStg.get("overrideThemeFlag") === BUILD_TIME;
  if (!isOverride) {
    settings = defu(overrideThemeSettings, settings);
    localStg.set("overrideThemeFlag", BUILD_TIME);
  }

  return settings;
}
```

**关键点**：

- 开发模式不缓存，方便调试
- 生产模式从 localStorage 恢复用户设置
- 支持版本更新时的配置覆盖机制

---

## 暗色模式切换

### 实现原理

暗色模式通过以下方式实现：

1. **CSS 类切换**：在 `<html>` 元素上添加/移除 `dark` 类
2. **CSS 变量覆盖**：暗色模式下使用不同的 CSS 变量值

### 核心函数

```typescript
// src/store/modules/theme/shared.ts
export function toggleCssDarkMode(darkMode = false) {
  const { add, remove } = toggleHtmlClass(DARK_CLASS); // DARK_CLASS = 'dark'

  if (darkMode) {
    add(); // document.documentElement.classList.add('dark')
  } else {
    remove(); // document.documentElement.classList.remove('dark')
  }
}
```

### 主题方案切换

在 `dark-mode.vue` 组件中：

```vue
<template>
  <ElTabs v-model="themeStore.themeScheme" @tab-change="handleSegmentChange">
    <ElTabPane name="light">
      <SvgIcon icon="material-symbols:sunny" />
    </ElTabPane>
    <ElTabPane name="dark">
      <SvgIcon icon="material-symbols:nightlight-rounded" />
    </ElTabPane>
    <ElTabPane name="auto">
      <SvgIcon icon="material-symbols:hdr-auto" />
    </ElTabPane>
  </ElTabs>
</template>

<script setup>
function handleSegmentChange(value: string | number) {
  themeStore.setThemeScheme(value as UnionKey.ThemeScheme);
}
</script>
```

### 自动模式

当选择 `auto` 模式时，系统会监听操作系统的主题偏好：

```typescript
const osTheme = usePreferredColorScheme(); // 使用 @vueuse/core

const darkMode = computed(() => {
  if (settings.value.themeScheme === "auto") {
    return osTheme.value === "dark"; // 跟随系统
  }
  return settings.value.themeScheme === "dark";
});
```

---

## 主题颜色系统

### 颜色配置结构

主题颜色包括：

- **primary**：主色（主题色）
- **info**：信息色（可跟随主色）
- **success**：成功色
- **warning**：警告色
- **error**：错误色

### 颜色更新流程

在 `theme-color.vue` 组件中：

```vue
<template>
  <SettingItem
    v-for="(_, key) in themeStore.themeColors"
    :key="key"
    :label="$t(`theme.themeColor.${key}`)"
  >
    <ElColorPicker
      v-model="themeStore.themeColors[key]"
      @change="handleUpdateColor($event, key)"
    />
  </SettingItem>
</template>

<script setup>
function handleUpdateColor(color: string | null, key: App.Theme.ThemeColorKey) {
  if (color !== null) {
    themeStore.updateThemeColors(key, color);
  }
}
</script>
```

### 颜色调色板生成

当启用"推荐颜色"模式时，系统会生成完整的颜色调色板：

```typescript
// src/store/modules/theme/shared.ts
function createThemePaletteColors(
  colors: App.Theme.ThemeColor,
  recommended = false,
) {
  const colorKeys = Object.keys(colors) as App.Theme.ThemeColorKey[];
  const colorPaletteVar = {} as App.Theme.ThemePaletteColor;

  colorKeys.forEach((key) => {
    // 生成 50-950 的色阶
    const colorMap = getColorPalette(colors[key], recommended);
    colorPaletteVar[key] = colorMap.get(500)!; // 主色使用 500

    // 生成所有色阶变量
    colorMap.forEach((hex, number) => {
      colorPaletteVar[`${key}-${number}`] = hex;
    });
  });

  return colorPaletteVar;
}
```

**色阶说明**：

- 50-400：浅色系（用于背景、边框等）
- 500：主色（用于主要元素）
- 600-950：深色系（用于悬停、按下等状态）

### 推荐颜色模式

启用推荐颜色后，系统会自动从颜色调色板中选择合适的颜色：

```typescript
function updateThemeColors(key: App.Theme.ThemeColorKey, color: string) {
  let colorValue = color;

  if (settings.value.recommendColor) {
    // 从调色板中选择 500 号色
    colorValue = getPaletteColorByNumber(color, 500, true);
  }

  if (key === "primary") {
    settings.value.themeColor = colorValue;
  } else {
    settings.value.otherColor[key] = colorValue;
  }
}
```

---

## CSS变量注入机制

### CSS 变量定义

在 `src/theme/vars.ts` 中定义了所有主题相关的 CSS 变量：

```typescript
export const themeVars: App.Theme.ThemeTokenCSSVars = {
  colors: {
    // 颜色调色板变量
    primary: "rgb(var(--primary-color))",
    "primary-50": "rgb(var(--primary-50-color))",
    // ... 其他色阶

    // 布局颜色
    container: "rgb(var(--container-bg-color))",
    layout: "rgb(var(--layout-bg-color))",
    "base-text": "rgb(var(--base-text-color))",
  },
  boxShadow: {
    header: "var(--header-box-shadow)",
    sider: "var(--sider-box-shadow)",
    tab: "var(--tab-box-shadow)",
  },
};
```

### 变量注入流程

1. **创建主题 Token**

```typescript
export function createThemeToken(
  colors: App.Theme.ThemeColor,
  tokens?: App.Theme.ThemeSetting["tokens"],
  recommended = false,
) {
  // 1. 生成颜色调色板
  const paletteColors = createThemePaletteColors(colors, recommended);

  // 2. 合并亮色主题 Token
  const themeTokens: App.Theme.ThemeTokenCSSVars = {
    colors: {
      ...paletteColors,
      nprogress: paletteColors.primary,
      ...light.colors,
    },
    boxShadow: { ...light.boxShadow },
  };

  // 3. 合并暗色主题 Token（覆盖亮色）
  const darkThemeTokens: App.Theme.ThemeTokenCSSVars = {
    colors: {
      ...themeTokens.colors,
      ...dark?.colors, // 暗色模式覆盖
    },
    boxShadow: {
      ...themeTokens.boxShadow,
      ...dark?.boxShadow,
    },
  };

  return { themeTokens, darkThemeTokens };
}
```

2. **注入到 DOM**

```typescript
export function addThemeVarsToGlobal(
  tokens: App.Theme.BaseToken,
  darkTokens: App.Theme.BaseToken,
) {
  // 1. 将 Token 转换为 CSS 变量字符串
  const cssVarStr = getCssVarByTokens(tokens);
  const darkCssVarStr = getCssVarByTokens(darkTokens);

  // 2. 生成 CSS 规则
  const css = `:root { ${cssVarStr} }`;
  const darkCss = `html.${DARK_CLASS} { ${darkCssVarStr} }`;

  // 3. 创建或更新 style 标签
  const styleId = "theme-vars";
  const style =
    document.querySelector(`#${styleId}`) || document.createElement("style");
  style.id = styleId;
  style.textContent = css + darkCss;

  // 4. 注入到 head
  document.head.appendChild(style);
}
```

3. **Token 转 CSS 变量**

```typescript
function getCssVarByTokens(tokens: App.Theme.BaseToken) {
  const styles: string[] = [];

  for (const [key, tokenValues] of Object.entries(themeVars)) {
    for (const [tokenKey, tokenValue] of Object.entries(tokenValues)) {
      // 提取 CSS 变量名（去掉 var() 和 rgb()）
      let cssVarsKey = removeVarPrefix(tokenValue);
      let cssValue = tokens[key][tokenKey];

      if (key === "colors") {
        cssVarsKey = removeRgbPrefix(cssVarsKey);
        // 将颜色值转换为 RGB 格式：r g b
        const { r, g, b } = getRgb(cssValue);
        cssValue = `${r} ${g} ${b}`;
      }

      styles.push(`${cssVarsKey}: ${cssValue}`);
    }
  }

  return styles.join(";");
}
```

### 生成的 CSS 示例

最终生成的 CSS 如下：

```css
:root {
  --primary-color: 100 108 255;
  --primary-50-color: 239 240 255;
  --container-bg-color: 255 255 255;
  --layout-bg-color: 247 250 252;
  --base-text-color: 31 31 31;
  --header-box-shadow: 0 1px 2px rgb(0, 21, 41, 0.08);
}

html.dark {
  --container-bg-color: 28 28 28;
  --layout-bg-color: 18 18 18;
  --base-text-color: 224 224 224;
}
```

**注意**：颜色值使用 RGB 格式（空格分隔），便于在 CSS 中使用 `rgb(var(--primary-color))` 并支持透明度。

---

## UI组件主题适配

### Naive UI 主题配置

项目使用 Naive UI 作为组件库，需要为其生成主题配置：

```typescript
export function getNaiveTheme(
  colors: App.Theme.ThemeColor,
  recommended = false,
) {
  const colorActions: NaiveColorAction[] = [
    { scene: "", handler: (color) => color },
    { scene: "Suppl", handler: (color) => color },
    {
      scene: "Hover",
      handler: (color) => getPaletteColorByNumber(color, 500, recommended),
    },
    {
      scene: "Pressed",
      handler: (color) => getPaletteColorByNumber(color, 700, recommended),
    },
    { scene: "Active", handler: (color) => addColorAlpha(color, 0.1) },
  ];

  const themeColors: NaiveThemeColor = {};

  // 为每种颜色生成不同状态
  colorEntries.forEach((color) => {
    colorActions.forEach((action) => {
      const [colorType, colorValue] = color;
      const colorKey = `${colorType}Color${action.scene}`;
      themeColors[colorKey] = action.handler(colorValue);
    });
  });

  return {
    common: {
      ...themeColors,
      borderRadius: "6px",
    },
    LoadingBar: {
      colorLoading: colors.primary,
    },
    Tag: {
      borderRadius: "6px",
    },
  };
}
```

### 主题应用

在应用入口处应用主题：

```typescript
// 在组件中使用
const uiTheme = computed(() =>
  getNaiveTheme(themeColors.value, settings.value.recommendColor)
);

// 传递给 Naive UI 的 ConfigProvider
<ElConfigProvider :theme="uiTheme">
  <!-- 应用内容 -->
</ElConfigProvider>
```

---

## 主题设置持久化

### 自动缓存

主题设置会在以下时机自动保存到 localStorage：

1. **页面关闭/刷新时**：

```typescript
useEventListener(window, "beforeunload", () => {
  cacheThemeSettings();
});

function cacheThemeSettings() {
  const isProd = import.meta.env.PROD;
  if (!isProd) return;
  localStg.set("themeSettings", settings.value);
}
```

2. **设置变更时**：

```typescript
watch(
  darkMode,
  (val) => {
    toggleCssDarkMode(val);
    localStg.set("darkMode", val); // 立即保存
  },
  { immediate: true },
);

watch(
  themeColors,
  (val) => {
    setupThemeVarsToGlobal();
    localStg.set("themeColor", val.primary); // 立即保存
  },
  { immediate: true },
);
```

### 存储结构

```typescript
interface ThemeSetting {
  themeScheme: "light" | "dark" | "auto";
  grayscale: boolean;
  colourWeakness: boolean;
  recommendColor: boolean;
  themeColor: string;
  otherColor: {
    info: string;
    success: string;
    warning: string;
    error: string;
  };
  isInfoFollowPrimary: boolean;
  layout: {
    /* ... */
  };
  page: {
    /* ... */
  };
  header: {
    /* ... */
  };
  tab: {
    /* ... */
  };
  sider: {
    /* ... */
  };
  footer: {
    /* ... */
  };
  watermark: {
    /* ... */
  };
  tokens: {
    /* ... */
  };
}
```

---

## 用户界面组件

### 主题抽屉（Theme Drawer）

主题抽屉是用户配置主题的主要界面，位于 `src/layouts/modules/theme-drawer/index.vue`：

```vue
<template>
  <ElDrawer
    v-model="appStore.themeDrawerVisible"
    :title="$t('theme.themeDrawerTitle')"
    :size="360"
  >
    <DarkMode />
    <!-- 暗色模式切换 -->
    <LayoutMode />
    <!-- 布局模式选择 -->
    <ThemeColor />
    <!-- 主题颜色配置 -->
    <PageFun />
    <!-- 页面功能设置 -->
    <template #footer>
      <ConfigOperation />
      <!-- 配置操作（导入/导出/重置） -->
    </template>
  </ElDrawer>
</template>
```

### 暗色模式组件

`dark-mode.vue` 提供：

- **主题方案切换**：亮色/暗色/自动
- **侧边栏反色**：仅在亮色模式下显示
- **灰度模式**：将页面转换为灰度
- **色弱模式**：增强对比度

```vue
<template>
  <ElDivider>{{ $t("theme.themeSchema.title") }}</ElDivider>
  <div class="flex-col-stretch gap-16px">
    <!-- 主题方案切换 -->
    <ElTabs v-model="themeStore.themeScheme" @tab-change="handleSegmentChange">
      <ElTabPane v-for="(_, key) in themeSchemaRecord" :key="key" :name="key">
        <SvgIcon :icon="icons[key]" />
      </ElTabPane>
    </ElTabs>

    <!-- 侧边栏反色（条件显示） -->
    <Transition name="sider-inverted">
      <SettingItem v-if="showSiderInverted" :label="$t('theme.sider.inverted')">
        <ElSwitch v-model="themeStore.sider.inverted" />
      </SettingItem>
    </Transition>

    <!-- 灰度模式 -->
    <SettingItem :label="$t('theme.grayscale')">
      <ElSwitch v-model="themeStore.grayscale" />
    </SettingItem>

    <!-- 色弱模式 -->
    <SettingItem :label="$t('theme.colourWeakness')">
      <ElSwitch v-model="themeStore.colourWeakness" />
    </SettingItem>
  </div>
</template>
```

### 主题颜色组件

`theme-color.vue` 提供：

- **推荐颜色开关**：启用后自动生成调色板
- **颜色选择器**：为每种颜色提供颜色选择器
- **信息色跟随主色**：可选项

```vue
<template>
  <ElDivider>{{ $t("theme.themeColor.title") }}</ElDivider>
  <div class="flex-col-stretch gap-12px">
    <!-- 推荐颜色开关 -->
    <SettingItem :label="$t('theme.recommendColor')">
      <ElSwitch v-model="themeStore.recommendColor" />
    </SettingItem>

    <!-- 颜色选择器列表 -->
    <SettingItem
      v-for="(_, key) in themeStore.themeColors"
      :key="key"
      :label="$t(`theme.themeColor.${key}`)"
    >
      <ElColorPicker
        v-model="themeStore.themeColors[key]"
        @change="handleUpdateColor($event, key)"
      />
    </SettingItem>
  </div>
</template>
```

### 辅助功能

#### 灰度模式

```typescript
export function toggleAuxiliaryColorModes(
  grayscaleMode = false,
  colourWeakness = false,
) {
  const htmlElement = document.documentElement;
  htmlElement.style.filter = [
    grayscaleMode ? "grayscale(100%)" : "",
    colourWeakness ? "invert(80%)" : "",
  ]
    .filter(Boolean)
    .join(" ");
}
```

通过 CSS `filter` 属性实现全局灰度/色弱效果。

---

## 完整流程示例

### 场景：用户切换主题颜色

1. **用户操作**：

   - 在主题抽屉中打开颜色选择器
   - 选择新的主色 `#3b82f6`

2. **组件响应**：

   ```vue
   <ElColorPicker
     v-model="themeStore.themeColors[key]"
     @change="handleUpdateColor($event, key)"
   />
   ```

3. **Store 更新**：

   ```typescript
   function updateThemeColors(key: "primary", color: "#3b82f6") {
     if (settings.value.recommendColor) {
       color = getPaletteColorByNumber(color, 500, true);
     }
     settings.value.themeColor = color;
   }
   ```

4. **计算属性响应**：

   ```typescript
   const themeColors = computed(() => ({
     primary: settings.value.themeColor,
     // ...
   }));
   ```

5. **Watch 触发**：

   ```typescript
   watch(themeColors, (val) => {
     setupThemeVarsToGlobal(); // 更新 CSS 变量
     localStg.set("themeColor", val.primary); // 保存到 localStorage
   });
   ```

6. **CSS 变量更新**：

   ```typescript
   function setupThemeVarsToGlobal() {
     const { themeTokens, darkThemeTokens } = createThemeToken(
       themeColors.value,
       settings.value.tokens,
       settings.value.recommendColor,
     );
     addThemeVarsToGlobal(themeTokens, darkThemeTokens);
   }
   ```

7. **DOM 更新**：

   - 更新 `<style id="theme-vars">` 标签内容
   - 所有使用 CSS 变量的元素自动更新颜色

8. **UI 组件更新**：
   ```typescript
   const uiTheme = computed(() =>
     getNaiveTheme(themeColors.value, settings.value.recommendColor),
   );
   ```
   - Naive UI 组件自动应用新主题

### 场景：用户切换暗色模式

1. **用户操作**：点击暗色模式标签

2. **Store 更新**：

   ```typescript
   function setThemeScheme('dark') {
     settings.value.themeScheme = 'dark';
   }
   ```

3. **计算属性响应**：

   ```typescript
   const darkMode = computed(() => {
     return settings.value.themeScheme === "dark"; // true
   });
   ```

4. **Watch 触发**：

   ```typescript
   watch(darkMode, (val) => {
     toggleCssDarkMode(val); // 添加 'dark' 类
     localStg.set("darkMode", val);
   });
   ```

5. **DOM 更新**：

   ```typescript
   document.documentElement.classList.add("dark");
   ```

6. **CSS 生效**：
   ```css
   html.dark {
     --container-bg-color: 28 28 28;
     --layout-bg-color: 18 18 18;
     --base-text-color: 224 224 224;
   }
   ```
   - 所有使用这些变量的元素自动切换为暗色

---

## 总结

该主题切换系统具有以下特点：

1. **响应式设计**：使用 Vue 3 的响应式系统，状态变更自动同步到 UI
2. **CSS 变量驱动**：通过 CSS 变量实现主题切换，性能优异
3. **持久化存储**：自动保存用户设置，刷新后恢复
4. **类型安全**：完整的 TypeScript 类型定义
5. **可扩展性**：易于添加新的主题配置项
6. **用户体验**：实时预览，无需刷新页面

通过这套系统，用户可以灵活地自定义应用的外观，同时开发者可以轻松地维护和扩展主题功能。

你想深入了解基于Vue3实现暗黑模式切换的底层原理，并且需要清晰的实现思路和代码示例，我会从核心原理到具体实现逐步拆解，让你理解每一步的逻辑。

## 一、暗黑模式切换的核心原理

Vue3实现暗黑模式切换的核心是**「CSS变量 + Vue3响应式状态 + 根元素类名动态切换」**，辅以本地存储持久化状态，具体拆解为3个核心点：

1. **样式层：CSS变量（自定义属性）**
   将页面的颜色、背景、边框等样式抽离为全局CSS变量，通过切换根元素（`<html>`/`<body>`）的类名（如`.dark`），让不同类名下的CSS变量生效，实现样式全局切换。
2. **逻辑层：Vue3响应式状态**
   用Vue3的`ref`/`reactive`管理「是否开启暗黑模式」的状态，状态变化时触发视图更新（比如切换按钮的显示、根元素类名的修改）。
3. **持久化层：本地存储（localStorage）**
   将暗黑模式的状态保存到`localStorage`，页面刷新/重新打开时读取并恢复状态，避免每次刷新都重置。
4. **增强体验：系统偏好适配**
   通过`window.matchMedia`检测用户系统的暗黑模式偏好（如macOS的深色模式），初始化时优先匹配系统设置，提升用户体验。

## 二、完整实现步骤（Vue3 + Vite 示例）

### 步骤1：定义全局CSS变量（样式基础）

在项目的全局样式文件（如`src/assets/styles/main.css`）中，定义「默认模式」和「暗黑模式」的CSS变量，并绑定到根元素类名：

```css
/* main.css - 全局样式 */
/* 1. 重置默认样式（可选） */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  transition:
    background-color 0.3s ease,
    color 0.3s ease; /* 过渡动画，提升体验 */
}

/* 2. 默认模式（根元素无.dark类） */
:root {
  --bg-color: #ffffff; /* 背景色 */
  --text-color: #333333; /* 文字色 */
  --border-color: #e5e7eb; /* 边框色 */
  --card-bg: #f9fafb; /* 卡片背景 */
}

/* 3. 暗黑模式（根元素添加.dark类） */
:root.dark {
  --bg-color: #18181b; /* 暗黑背景 */
  --text-color: #e4e4e7; /* 暗黑文字 */
  --border-color: #3f3f46; /* 暗黑边框 */
  --card-bg: #27272a; /* 暗黑卡片 */
}

/* 4. 全局样式使用CSS变量 */
body {
  background-color: var(--bg-color);
  color: var(--text-color);
  min-height: 100vh;
}

/* 示例：卡片组件样式 */
.card {
  border: 1px solid var(--border-color);
  background-color: var(--card-bg);
  padding: 20px;
  border-radius: 8px;
  margin: 20px;
}
```

### 步骤2：封装暗黑模式Hook（Vue3组合式API）

在`src/composables/useDarkMode.js`中封装复用的Hook，集中管理「状态、切换逻辑、持久化、系统适配」：

```javascript
// useDarkMode.js - 暗黑模式Hook
import { ref, watch, onMounted } from "vue";

export function useDarkMode() {
  // 1. 定义响应式状态：是否开启暗黑模式
  const isDark = ref(false);

  // 2. 检测系统暗黑模式偏好的媒体查询
  const darkModeMedia = window.matchMedia("(prefers-color-scheme: dark)");

  // 3. 从localStorage读取持久化的状态（优先级：手动设置 > 系统偏好）
  const initDarkMode = () => {
    // 读取本地存储的状态（'dark'/'light'）
    const savedMode = localStorage.getItem("color-scheme");
    if (savedMode) {
      // 有手动设置的状态，直接使用
      isDark.value = savedMode === "dark";
    } else {
      // 无手动设置，匹配系统偏好
      isDark.value = darkModeMedia.matches;
    }
    // 初始化根元素类名
    updateRootClass(isDark.value);
  };

  // 4. 更新根元素（html）的类名
  const updateRootClass = (dark) => {
    if (dark) {
      document.documentElement.classList.add("dark");
    } else {
      document.documentElement.classList.remove("dark");
    }
  };

  // 5. 切换暗黑模式的方法
  const toggleDarkMode = () => {
    isDark.value = !isDark.value;
    // 切换后持久化状态
    localStorage.setItem("color-scheme", isDark.value ? "dark" : "light");
  };

  // 6. 监听系统偏好变化（可选，增强体验）
  const watchSystemMode = () => {
    darkModeMedia.addEventListener("change", (e) => {
      // 只有当用户未手动设置时，才跟随系统变化
      if (!localStorage.getItem("color-scheme")) {
        isDark.value = e.matches;
        updateRootClass(e.matches);
      }
    });
  };

  // 7. 生命周期：挂载时初始化
  onMounted(() => {
    initDarkMode();
    watchSystemMode();
  });

  // 8. 监听isDark变化，自动更新根元素类名
  watch(isDark, (newVal) => {
    updateRootClass(newVal);
  });

  // 暴露给组件使用的状态和方法
  return {
    isDark,
    toggleDarkMode,
  };
}
```

### 步骤3：在Vue组件中使用

在`src/App.vue`中引入Hook，实现切换按钮和样式展示：

```vue
<template>
  <div class="app">
    <!-- 暗黑模式切换按钮 -->
    <button
      @click="toggleDarkMode"
      class="toggle-btn"
      :style="{
        background: isDark ? 'var(--card-bg)' : '#f0f0f0',
        color: 'var(--text-color)',
        borderColor: 'var(--border-color)',
      }"
    >
      {{ isDark ? "切换为浅色模式" : "切换为暗黑模式" }}
    </button>

    <!-- 示例卡片：展示样式切换效果 -->
    <div class="card">
      <h2>Vue3暗黑模式示例</h2>
      <p>当前模式：{{ isDark ? "暗黑模式" : "浅色模式" }}</p>
      <p>CSS变量驱动的样式切换，响应式状态管理</p>
    </div>
  </div>
</template>

<script setup>
// 引入封装的Hook
import { useDarkMode } from "./composables/useDarkMode";
// 解构出状态和切换方法
const { isDark, toggleDarkMode } = useDarkMode();
</script>

<style scoped>
.app {
  padding: 40px;
}

.toggle-btn {
  padding: 8px 16px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  margin-bottom: 20px;
}
</style>
```

### 步骤4：入口文件引入全局样式

在`src/main.js`中引入全局CSS文件，确保样式全局生效：

```javascript
// main.js
import { createApp } from "vue";
import App from "./App.vue";
import "./assets/styles/main.css"; // 引入全局样式

createApp(App).mount("#app");
```

## 三、关键原理详解

### 1. CSS变量的作用

CSS变量（`--xxx`）是实现样式切换的核心，它允许我们将样式值抽象为「变量」，通过修改根元素的类名，让不同类名下的变量值覆盖生效。比如：

- 浅色模式下，`:root`的`--bg-color`是`#ffffff`；
- 暗黑模式下，`:root.dark`的`--bg-color`是`#18181b`；
- 页面所有使用`var(--bg-color)`的元素都会自动继承当前根元素的变量值，实现全局样式切换。

### 2. Vue3响应式的作用

`isDark`是用`ref`创建的响应式状态，当调用`toggleDarkMode`修改`isDark.value`时：

- Vue3会监听`isDark`的变化，触发`watch`回调，自动更新根元素的类名；
- 组件中绑定`isDark`的模板（如按钮文字、样式）会实时更新，实现视图响应式变化。

### 3. 持久化与系统适配的逻辑

- **持久化**：通过`localStorage`保存用户手动切换的模式（`dark`/`light`），页面刷新后优先读取该值，避免状态丢失；
- **系统适配**：`window.matchMedia('(prefers-color-scheme: dark)')`可以检测系统的暗黑模式偏好，初始化时如果用户没有手动设置过，就跟随系统；同时监听系统偏好的变化，动态调整（仅当用户未手动设置时）。

## 四、避免常见问题

1. **页面闪烁**：如果初始化时先渲染浅色模式再切换暗黑模式，会出现闪烁。解决方法：在`index.html`的`<head>`中提前加入判断逻辑，避免渲染前的样式不一致：

```html
<!-- public/index.html -->
<head>
  <script>
    // 提前检测并设置根元素类名，避免闪烁
    const savedMode = localStorage.getItem("color-scheme");
    const isDark = savedMode
      ? savedMode === "dark"
      : window.matchMedia("(prefers-color-scheme: dark)").matches;
    if (isDark) document.documentElement.classList.add("dark");
  </script>
</head>
```

2. **第三方组件适配**：如果使用Element Plus等UI库，需结合其暗黑模式配置（如`ConfigProvider`），确保第三方组件也能跟随全局模式切换。

### 总结

Vue3实现暗黑模式切换的核心关键点：

1. **样式层**：通过`CSS变量 + 根元素类名切换`实现全局样式的动态覆盖；
2. **逻辑层**：用Vue3的`ref`管理响应式状态，`watch`监听状态变化并更新DOM类名；
3. **体验层**：通过`localStorage`持久化状态，`matchMedia`适配系统偏好，提升用户体验。

整个实现的核心是「分离样式和逻辑」：样式的切换交给CSS变量和类名，逻辑的管理交给Vue3的响应式，两者结合既简洁又易于维护。

你想了解 CSS 中的 `:root` 伪类，它是之前讲解伪类时未详细提及的一个核心结构伪类，我会从定义、核心作用、用法和特点等方面帮你彻底搞懂它。

### 一、:root 伪类的核心定义

`:root` 是 CSS 的**结构伪类**，表示**文档的根元素**——在 HTML 文档中，根元素就是 `<html>` 标签（可以理解为 `:root` 是 `<html>` 元素的“伪类版选择器”）；如果是 XML/SVG 等文档，`:root` 会对应其自身的根元素。

核心特点：

- `:root` 选择的元素和 `html` 选择器完全相同，但 `:root` 的**优先级更高**（伪类选择器优先级 > 普通元素选择器）。
- `:root` 的作用域是**全局**，整个文档的所有元素都能访问到它定义的样式/变量。

### 二、:root 的核心用途（最常用场景）

`:root` 最核心、最实用的用法是**定义全局 CSS 变量（自定义属性）**，这也是现代 CSS 开发中 `:root` 的主要价值。

#### 1. 定义全局 CSS 变量

通过 `:root` 定义的变量可以在整个文档的任意元素中复用，方便统一管理主题色、字体大小、间距等全局样式，后期维护只需修改根变量，无需逐个修改元素样式。

```css
/* 1. 在:root中定义全局CSS变量（变量名必须以--开头） */
:root {
  /* 主题色 */
  --primary-color: #0099ff;
  /* 辅助色 */
  --secondary-color: #ff6600;
  /* 全局间距 */
  --base-margin: 16px;
  /* 全局字体大小 */
  --base-font-size: 14px;
}

/* 2. 在任意元素中使用这些变量（通过var()函数） */
body {
  font-size: var(--base-font-size);
  margin: var(--base-margin);
}

.btn-primary {
  background-color: var(--primary-color);
  color: #fff;
  padding: 8px var(--base-margin);
}

.card {
  border: 1px solid var(--primary-color);
  margin-bottom: var(--base-margin);
}

/* 3. 可局部覆盖变量（不影响全局） */
.card-warning {
  --primary-color: #ffcc00; /* 局部覆盖主题色 */
  border-color: var(--primary-color);
}
```

#### 2. 对比：:root vs html 选择器

两者选中的是同一个元素，但优先级不同，看下面的示例就能直观理解：

```css
/* 普通元素选择器：html */
html {
  background-color: #f5f5f5; /* 这行样式会被覆盖 */
}

/* 伪类选择器：:root（优先级更高） */
:root {
  background-color: #ffffff; /* 最终生效的是这行 */
}
```

优先级规则：`伪类选择器 (:root)` > `普通元素选择器 (html)`，如果想让 `html` 选择器的样式生效，需要加 `!important`，但不推荐这么做。

#### 3. 其他小众用途

除了定义变量，也可以用 `:root` 设置全局基础样式（比如重置默认样式），但不如定义变量常用：

```css
:root {
  /* 重置盒模型 */
  box-sizing: border-box;
  /* 清除默认边距 */
  margin: 0;
  padding: 0;
}

*,
*::before,
*::after {
  box-sizing: inherit; /* 继承根元素的盒模型设置 */
}
```

### 三、:root 的关键特点

1. **全局作用域**：在 `:root` 中定义的 CSS 变量是全局的，文档内所有元素（包括伪元素）都能通过 `var()` 访问。
2. **优先级高于普通根元素选择器**：`html { ... }` 的样式会被 `:root { ... }` 覆盖，除非加 `!important`。
3. **跨文档兼容**：不仅适用于 HTML，在 SVG、XML 等文档中也能选中其根元素（比如 SVG 中的 `<svg>` 标签）。
4. **变量可覆盖**：局部元素中重新定义同名变量，会覆盖全局变量（局部优先），灵活适配不同模块样式。

### 总结

1. `:root` 是选中文档根元素的伪类（HTML 中对应 `<html>`），优先级高于普通 `html` 选择器。
2. 它的核心价值是**定义全局 CSS 变量**，实现样式的统一管理和复用，是现代 CSS 主题化开发的基础。
3. 全局变量可在局部元素中覆盖，兼顾全局统一和局部灵活。

# CSS伪类和伪元素详解

## 一、基本概念

### 伪类（Pseudo-classes）

- **定义**：用于选择处于**特定状态**的元素
- **语法**：单冒号`:`（CSS3前）或双冒号`::`（CSS3后，但通常仍用单冒号）
- **作用**：基于元素的状态（如悬停、焦点、访问状态等）应用样式

### 伪元素（Pseudo-elements）

- **定义**：用于选择元素的**特定部分**或在元素前后插入内容
- **语法**：双冒号`::`（CSS3推荐），单冒号`:`（为向后兼容）
- **作用**：创建虚拟元素来设置元素特定部分的样式

## 二、常见伪类详解

### 1. 状态相关伪类

```css
/* 链接状态 */
a:link {
  color: blue;
} /* 未访问链接 */
a:visited {
  color: purple;
} /* 已访问链接 */
a:hover {
  color: red;
} /* 鼠标悬停 */
a:active {
  color: orange;
} /* 激活/点击时 */
a:focus {
  outline: 2px solid blue;
} /* 获得焦点时 */

/* 表单元素状态 */
input:disabled {
  opacity: 0.5;
} /* 禁用状态 */
input:enabled {
  opacity: 1;
} /* 启用状态 */
input:checked {
  accent-color: green;
} /* 选中状态 */
input:required {
  border-color: red;
} /* 必填字段 */
input:optional {
  border-color: #ccc;
} /* 可选字段 */
input:valid {
  border-color: green;
} /* 验证通过 */
input:invalid {
  border-color: red;
} /* 验证失败 */
input:in-range {
  color: green;
} /* 值在范围内 */
input:out-of-range {
  color: red;
} /* 值超出范围 */
```

### 2. 结构相关伪类

```css
/* 基于位置的伪类 */
li:first-child {
  color: red;
} /* 第一个子元素 */
li:last-child {
  color: blue;
} /* 最后一个子元素 */
li:nth-child(2) {
  color: green;
} /* 第2个子元素 */
li:nth-child(odd) {
  background: #f0f0f0;
} /* 奇数子元素 */
li:nth-child(even) {
  background: #fff;
} /* 偶数子元素 */
li:nth-child(3n) {
  font-weight: bold;
} /* 每第3个子元素 */
li:nth-child(3n + 1) {
  color: purple;
} /* 3n+1公式 */
li:nth-last-child(2) {
  font-style: italic;
} /* 倒数第2个 */

/* 基于类型的伪类 */
p:first-of-type {
  font-size: 1.2em;
} /* 同类中第一个 */
p:last-of-type {
  font-size: 0.9em;
} /* 同类中最后一个 */
p:nth-of-type(2) {
  color: teal;
} /* 同类中第2个 */
p:only-of-type {
  border: 1px solid #000;
} /* 唯一此类元素 */

/* 其他结构伪类 */
p:only-child {
  text-align: center;
} /* 唯一子元素 */
:empty {
  display: none;
} /* 空元素 */
:root {
  /* 文档根元素，等同于html选择器 */
  --primary-color: #007bff;
}
```

### 3. 逻辑伪类

```css
/* 否定伪类 */
:not(.exclude) {
  /* 选择所有不具有.exclude类的元素 */
  margin: 10px;
}

/* 配合其他选择器使用 */
div:not(:first-child) {
  margin-top: 20px;
}

input:not([type="checkbox"]):not([type="radio"]) {
  width: 200px;
}
```

### 4. 交互状态伪类

```css
/* 鼠标交互 */
button:hover {
  background-color: #0056b3;
  transform: translateY(-2px);
  transition: all 0.3s ease;
}

button:active {
  transform: translateY(0);
}

/* 焦点相关 */
:focus-visible {
  /* 键盘焦点时才显示，鼠标点击时不显示 */
  outline: 2px solid blue;
}

:focus-within {
  /* 当元素内部有子元素获得焦点时 */
  background-color: #f0f8ff;
}
```

## 三、常见伪元素详解

### 1. 内容生成伪元素

```css
/* ::before 和 ::after */
.element::before {
  content: "前缀: ";
  color: #666;
  font-weight: bold;
}

.element::after {
  content: " (后缀)";
  color: #999;
  font-size: 0.9em;
}

/* content属性值类型 */
.quote::before {
  content: open-quote; /* 开始引号 */
}

.quote::after {
  content: close-quote; /* 结束引号 */
}

.icon::before {
  content: "";
  display: inline-block;
  width: 16px;
  height: 16px;
  background-image: url("icon.svg");
  background-size: contain;
}

.counter::before {
  content: counter(section) ". "; /* 使用计数器 */
}
```

### 2. 文本相关伪元素

```css
/* 首行和首字母 */
p::first-line {
  font-weight: bold;
  font-size: 1.1em;
  color: #333;
}

p::first-letter {
  font-size: 3em;
  float: left;
  line-height: 1;
  margin-right: 5px;
  color: #900;
  font-family: Georgia, serif;
}

/* 选中文本样式 */
::selection {
  background-color: #ffeb3b;
  color: #000;
}

::-moz-selection {
  /* Firefox兼容 */
  background-color: #ffeb3b;
  color: #000;
}

/* 占位符文本 */
input::placeholder {
  color: #999;
  font-style: italic;
}
```

### 3. 表单相关伪元素

```css
/* 自定义复选框/单选框 */
input[type="checkbox"]::before {
  content: "";
  display: inline-block;
  width: 16px;
  height: 16px;
  border: 2px solid #ccc;
  border-radius: 3px;
}

input[type="checkbox"]:checked::before {
  content: "✓";
  background-color: #007bff;
  color: white;
  text-align: center;
  line-height: 16px;
}
```

## 四、高级应用示例

### 1. 清除浮动

```css
.clearfix::after {
  content: "";
  display: table;
  clear: both;
}
```

### 2. 自定义列表样式

```css
.custom-list li {
  counter-increment: item;
  margin-bottom: 10px;
}

.custom-list li::before {
  content: counter(item) ". ";
  font-weight: bold;
  color: #007bff;
  margin-right: 10px;
}
```

### 3. 工具提示

```css
.tooltip {
  position: relative;
}

.tooltip:hover::after {
  content: attr(data-tooltip);
  position: absolute;
  bottom: 100%;
  left: 50%;
  transform: translateX(-50%);
  background: #333;
  color: white;
  padding: 5px 10px;
  border-radius: 4px;
  white-space: nowrap;
  font-size: 0.9em;
}
```

### 4. 卡片效果

```css
.card::before {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 4px;
  background: linear-gradient(90deg, #ff6b6b, #4ecdc4);
}
```

## 五、浏览器兼容性说明

| 特性             | IE  | Edge | Chrome | Firefox | Safari |
| ---------------- | --- | ---- | ------ | ------- | ------ |
| :hover (非链接)  | 7+  | 12+  | 1+     | 1+      | 1+     |
| :focus           | 8+  | 12+  | 1+     | 1+      | 1+     |
| :nth-child()     | 9+  | 12+  | 1+     | 3.5+    | 3.1+   |
| :not()           | 9+  | 12+  | 1+     | 3.5+    | 3.1+   |
| ::before/::after | 9+  | 12+  | 1+     | 3.5+    | 3.1+   |
| ::selection      | 9+  | 12+  | 1+     | 1.5+    | 1.1+   |
| :focus-within    | ✗   | 79+  | 67+    | 52+     | 10.1+  |

## 六、最佳实践

### 1. 命名规范

```css
/* 良好实践 */
.button--primary:hover {
  /* ... */
}

.form__input:focus {
  /* ... */
}

/* 避免过度使用 */
div div div p:first-child:hover::before {
  /* 过于复杂，难以维护 */
}
```

### 2. 性能考虑

- 避免使用过于复杂的选择器链
- 伪元素创建的内容无法被屏幕阅读器读取，重要内容不应仅用伪元素展示
- 大量使用伪元素可能增加内存消耗

### 3. 可访问性

```css
/* 提供键盘导航支持 */
button:focus {
  outline: 2px solid #007bff;
  outline-offset: 2px;
}

/* 确保伪元素内容对屏幕阅读器友好 */
[aria-label]::after {
  content: attr(aria-label);
  /* 确保视觉隐藏但屏幕阅读器可读 */
}
```

## 七、总结对比表

| 特性         | 伪类                 | 伪元素                  |
| ------------ | -------------------- | ----------------------- |
| 作用对象     | 整个元素             | 元素的部分内容          |
| 主要用途     | 选择特定状态         | 创建虚拟元素            |
| CSS级别      | CSS1开始引入         | CSS2开始引入            |
| 语法(CSS3)   | :                    | ::                      |
| 是否创建内容 | 否                   | 是（需配合content属性） |
| 常见示例     | :hover, :nth-child() | ::before, ::after       |

## 八、综合示例

```css
/* 完整示例：带进度步骤的导航 */
.steps {
  display: flex;
  counter-reset: step;
}

.step {
  flex: 1;
  position: relative;
  text-align: center;
  padding-top: 30px;
}

.step::before {
  content: counter(step);
  counter-increment: step;
  width: 30px;
  height: 30px;
  line-height: 30px;
  border-radius: 50%;
  background: #ddd;
  color: #666;
  position: absolute;
  top: 0;
  left: 50%;
  transform: translateX(-50%);
  z-index: 2;
}

.step.active::before {
  background: #007bff;
  color: white;
}

.step::after {
  content: "";
  position: absolute;
  top: 15px;
  left: -50%;
  right: 50%;
  height: 2px;
  background: #ddd;
  z-index: 1;
}

.step:first-child::after {
  display: none;
}

.step.active ~ .step::before {
  background: #ddd;
}

.step.active ~ .step::after {
  background: #ddd;
}
```

掌握伪类和伪元素能显著提升CSS开发效率，让你能够在不修改HTML结构的情况下实现复杂样式效果。在实际开发中，应根据具体需求合理选择使用，并注意浏览器兼容性和性能影响。
